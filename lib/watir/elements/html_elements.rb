# Autogenerated from HTML specification. Edits may be lost.
module Watir
  class HTMLElement < Element
    attribute(String, :title, :title)
    attribute(String, :lang, :lang)
    attribute("Boolean", :translate?, :translate)
    attribute(String, :dir, :dir)
    attribute(String, :dataset, :dataset)
    attribute("Boolean", :hidden?, :hidden)
    attribute(Integer, :tabindex, :tabIndex)
    attribute(String, :accesskey, :accessKey)
    attribute("Boolean", :draggable?, :draggable)
    attribute("Boolean", :spellcheck?, :spellcheck)
    attribute(String, :innertext, :innerText)
    attribute(String, :onabort, :onabort)
    attribute(String, :onblur, :onblur)
    attribute(String, :oncancel, :oncancel)
    attribute(String, :oncanplay, :oncanplay)
    attribute(String, :oncanplaythrough, :oncanplaythrough)
    attribute(String, :onchange, :onchange)
    attribute(String, :onclick, :onclick)
    attribute(String, :onclose, :onclose)
    attribute(String, :oncuechange, :oncuechange)
    attribute(String, :ondblclick, :ondblclick)
    attribute(String, :ondrag, :ondrag)
    attribute(String, :ondragend, :ondragend)
    attribute(String, :ondragenter, :ondragenter)
    attribute(String, :ondragexit, :ondragexit)
    attribute(String, :ondragleave, :ondragleave)
    attribute(String, :ondragover, :ondragover)
    attribute(String, :ondragstart, :ondragstart)
    attribute(String, :ondrop, :ondrop)
    attribute(String, :ondurationchange, :ondurationchange)
    attribute(String, :onemptied, :onemptied)
    attribute(String, :onended, :onended)
    attribute(String, :onerror, :onerror)
    attribute(String, :onfocus, :onfocus)
    attribute(String, :oninput, :oninput)
    attribute(String, :oninvalid, :oninvalid)
    attribute(String, :onkeydown, :onkeydown)
    attribute(String, :onkeypress, :onkeypress)
    attribute(String, :onkeyup, :onkeyup)
    attribute(String, :onload, :onload)
    attribute(String, :onloadeddata, :onloadeddata)
    attribute(String, :onloadedmetadata, :onloadedmetadata)
    attribute(String, :onloadstart, :onloadstart)
    attribute(String, :onmousedown, :onmousedown)
    attribute(String, :onmouseenter, :onmouseenter)
    attribute(String, :onmouseleave, :onmouseleave)
    attribute(String, :onmousemove, :onmousemove)
    attribute(String, :onmouseout, :onmouseout)
    attribute(String, :onmouseover, :onmouseover)
    attribute(String, :onmouseup, :onmouseup)
    attribute(String, :onwheel, :onwheel)
    attribute(String, :onpause, :onpause)
    attribute(String, :onplay, :onplay)
    attribute(String, :onplaying, :onplaying)
    attribute(String, :onprogress, :onprogress)
    attribute(String, :onratechange, :onratechange)
    attribute(String, :onreset, :onreset)
    attribute(String, :onresize, :onresize)
    attribute(String, :onscroll, :onscroll)
    attribute(String, :onseeked, :onseeked)
    attribute(String, :onseeking, :onseeking)
    attribute(String, :onselect, :onselect)
    attribute(String, :onshow, :onshow)
    attribute(String, :onstalled, :onstalled)
    attribute(String, :onsubmit, :onsubmit)
    attribute(String, :onsuspend, :onsuspend)
    attribute(String, :ontimeupdate, :ontimeupdate)
    attribute(String, :ontoggle, :ontoggle)
    attribute(String, :onvolumechange, :onvolumechange)
    attribute(String, :onwaiting, :onwaiting)
    attribute(String, :oncopy, :oncopy)
    attribute(String, :oncut, :oncut)
    attribute(String, :onpaste, :onpaste)
    attribute(String, :content_editable, :contentEditable)
    attribute("Boolean", :content_editable?, :isContentEditable)
  end
  class HTMLElementCollection < ElementCollection
  end

  class Font < HTMLElement
    attribute(String, :color, :color)
    attribute(String, :face, :face)
  end
  class FontCollection < ElementCollection
  end

  class Directory < HTMLElement
    attribute("Boolean", :compact?, :compact)
  end
  class DirectoryCollection < ElementCollection
  end

  class FrameSet < HTMLElement
    attribute(String, :cols, :cols)
    attribute(String, :onafterprint, :onafterprint)
    attribute(String, :onbeforeprint, :onbeforeprint)
    attribute(String, :onbeforeunload, :onbeforeunload)
    attribute(String, :onhashchange, :onhashchange)
    attribute(String, :onlanguagechange, :onlanguagechange)
    attribute(String, :onmessage, :onmessage)
    attribute(String, :onoffline, :onoffline)
    attribute(String, :ononline, :ononline)
    attribute(String, :onpagehide, :onpagehide)
    attribute(String, :onpageshow, :onpageshow)
    attribute(String, :onrejectionhandled, :onrejectionhandled)
    attribute(String, :onpopstate, :onpopstate)
    attribute(String, :onstorage, :onstorage)
    attribute(String, :onunhandledrejection, :onunhandledrejection)
    attribute(String, :onunload, :onunload)
  end
  class FrameSetCollection < ElementCollection
  end

  class Marquee < HTMLElement
    attribute(String, :behavior, :behavior)
    attribute(String, :bgcolor, :bgColor)
    attribute(String, :direction, :direction)
    attribute(Integer, :hspace, :hspace)
    attribute(Integer, :loop, :loop)
    attribute(Integer, :scrollamount, :scrollAmount)
    attribute(Integer, :scrolldelay, :scrollDelay)
    attribute("Boolean", :truespeed?, :trueSpeed)
    attribute(Integer, :vspace, :vspace)
    attribute(String, :onbounce, :onbounce)
    attribute(String, :onfinish, :onfinish)
    attribute(String, :onstart, :onstart)
  end
  class MarqueeCollection < ElementCollection
  end

  class Applet < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :alt, :alt)
    attribute(String, :archive, :archive)
    attribute(String, :code, :code)
    attribute(String, :codebase, :codeBase)
    attribute(Integer, :hspace, :hspace)
    attribute(String, :name, :name)
    attribute(String, :object, :object)
    attribute(Integer, :vspace, :vspace)
  end
  class AppletCollection < ElementCollection
  end

  class Canvas < HTMLElement
  end
  class CanvasCollection < ElementCollection
  end

  class Template < HTMLElement
    attribute(String, :content, :content)
  end
  class TemplateCollection < ElementCollection
  end

  class Script < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :type, :type)
    attribute(String, :charset, :charset)
    attribute("Boolean", :async?, :async)
    attribute("Boolean", :defer?, :defer)
    attribute(String, :crossorigin, :crossOrigin)
    attribute(String, :nonce, :nonce)
    attribute(String, :event, :event)
    attribute(String, :for, :htmlFor)
  end
  class ScriptCollection < ElementCollection
  end

  class Dialog < HTMLElement
    attribute("Boolean", :open?, :open)
    attribute(String, :returnvalue, :returnValue)
  end
  class DialogCollection < ElementCollection
  end

  class Details < HTMLElement
    attribute("Boolean", :open?, :open)
  end
  class DetailsCollection < ElementCollection
  end

  class Legend < HTMLElement
    attribute(String, :form, :form)
    attribute(String, :align, :align)
  end
  class LegendCollection < ElementCollection
  end

  class FieldSet < HTMLElement
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :name, :name)
    attribute(String, :type, :type)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
  end
  class FieldSetCollection < ElementCollection
  end

  class Meter < HTMLElement
    attribute(Float, :value, :value)
    attribute(Float, :min, :min)
    attribute(Float, :max, :max)
    attribute(Float, :low, :low)
    attribute(Float, :high, :high)
    attribute(Float, :optimum, :optimum)
    attribute(String, :labels, :labels)
  end
  class MeterCollection < ElementCollection
  end

  class Progress < HTMLElement
    attribute(Float, :value, :value)
    attribute(Float, :max, :max)
    attribute(Float, :position, :position)
    attribute(String, :labels, :labels)
  end
  class ProgressCollection < ElementCollection
  end

  class Output < HTMLElement
    attribute(String, :for, :htmlFor)
    attribute(String, :form, :form)
    attribute(String, :name, :name)
    attribute(String, :type, :type)
    attribute(String, :defaultvalue, :defaultValue)
    attribute(String, :value, :value)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
  end
  class OutputCollection < ElementCollection
  end

  class TextArea < HTMLElement
    attribute(String, :autocomplete, :autocomplete)
    attribute("Boolean", :autofocus?, :autofocus)
    attribute(Integer, :cols, :cols)
    attribute(String, :dirname, :dirName)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(Integer, :maxlength, :maxLength)
    attribute(Integer, :minlength, :minLength)
    attribute(String, :name, :name)
    attribute(String, :placeholder, :placeholder)
    attribute("Boolean", :readonly?, :readOnly)
    attribute("Boolean", :required?, :required)
    attribute(String, :wrap, :wrap)
    attribute(String, :type, :type)
    attribute(String, :defaultvalue, :defaultValue)
    attribute(String, :value, :value)
    attribute(Integer, :textlength, :textLength)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
    attribute(Integer, :selectionstart, :selectionStart)
    attribute(Integer, :selectionend, :selectionEnd)
    attribute(String, :selectiondirection, :selectionDirection)
  end
  class TextAreaCollection < ElementCollection
  end

  class Option < HTMLElement
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :label, :label)
    attribute("Boolean", :defaultselected?, :defaultSelected)
    attribute(String, :value, :value)
    attribute(Integer, :index, :index)
  end
  class OptionCollection < ElementCollection
  end

  class OptGroup < HTMLElement
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :label, :label)
  end
  class OptGroupCollection < ElementCollection
  end

  class DataList < HTMLElement
  end
  class DataListCollection < ElementCollection
  end

  class Select < HTMLElement
    attribute(String, :autocomplete, :autocomplete)
    attribute("Boolean", :autofocus?, :autofocus)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute("Boolean", :multiple?, :multiple)
    attribute(String, :name, :name)
    attribute("Boolean", :required?, :required)
    attribute(String, :type, :type)
    attribute(Integer, :length, :length)
    attribute(String, :selectedoptions, :selectedOptions)
    attribute(Integer, :selectedindex, :selectedIndex)
    attribute(String, :value, :value)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
  end
  class SelectCollection < ElementCollection
  end

  class Button < HTMLElement
    attribute("Boolean", :autofocus?, :autofocus)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :formaction, :formAction)
    attribute(String, :formenctype, :formEnctype)
    attribute(String, :formmethod, :formMethod)
    attribute("Boolean", :formnovalidate?, :formNoValidate)
    attribute(String, :formtarget, :formTarget)
    attribute(String, :name, :name)
    attribute(String, :type, :type)
    attribute(String, :value, :value)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
  end
  class ButtonCollection < ElementCollection
  end

  class Input < HTMLElement
    attribute(String, :accept, :accept)
    attribute(String, :alt, :alt)
    attribute(String, :autocomplete, :autocomplete)
    attribute("Boolean", :autofocus?, :autofocus)
    attribute("Boolean", :defaultchecked?, :defaultChecked)
    attribute("Boolean", :checked?, :checked)
    attribute(String, :dirname, :dirName)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :files, :files)
    attribute(String, :formaction, :formAction)
    attribute(String, :formenctype, :formEnctype)
    attribute(String, :formmethod, :formMethod)
    attribute("Boolean", :formnovalidate?, :formNoValidate)
    attribute(String, :formtarget, :formTarget)
    attribute("Boolean", :indeterminate?, :indeterminate)
    attribute(String, :list, :list)
    attribute(String, :max, :max)
    attribute(Integer, :maxlength, :maxLength)
    attribute(String, :min, :min)
    attribute(Integer, :minlength, :minLength)
    attribute("Boolean", :multiple?, :multiple)
    attribute(String, :name, :name)
    attribute(String, :pattern, :pattern)
    attribute(String, :placeholder, :placeholder)
    attribute("Boolean", :readonly?, :readOnly)
    attribute("Boolean", :required?, :required)
    attribute(String, :src, :src)
    attribute(String, :step, :step)
    attribute(String, :type, :type)
    attribute(String, :defaultvalue, :defaultValue)
    attribute(String, :value, :value)
    attribute(String, :valueasdate, :valueAsDate)
    attribute(Float, :valueasnumber, :valueAsNumber)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
    attribute(Integer, :selectionstart, :selectionStart)
    attribute(Integer, :selectionend, :selectionEnd)
    attribute(String, :selectiondirection, :selectionDirection)
    attribute(String, :align, :align)
    attribute(String, :usemap, :useMap)
  end
  class InputCollection < ElementCollection
  end

  class Label < HTMLElement
    attribute(String, :form, :form)
    attribute(String, :for, :htmlFor)
    attribute(String, :control, :control)
  end
  class LabelCollection < ElementCollection
  end

  class Form < HTMLElement
    attribute(String, :accept_charset, :acceptCharset)
    attribute(String, :action, :action)
    attribute(String, :autocomplete, :autocomplete)
    attribute(String, :enctype, :enctype)
    attribute(String, :encoding, :encoding)
    attribute(String, :method, :method)
    attribute(String, :name, :name)
    attribute("Boolean", :novalidate?, :noValidate)
    attribute(String, :target, :target)
    attribute(Integer, :length, :length)
  end
  class FormCollection < ElementCollection
  end

  class TableCell < HTMLElement
    attribute(Integer, :colspan, :colSpan)
    attribute(Integer, :rowspan, :rowSpan)
    attribute(String, :headers, :headers)
    attribute(Integer, :cellindex, :cellIndex)
    attribute(String, :align, :align)
    attribute(String, :axis, :axis)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute("Boolean", :nowrap?, :noWrap)
    attribute(String, :valign, :vAlign)
    attribute(String, :bgcolor, :bgColor)
  end
  class TableCellCollection < ElementCollection
  end

  class TableHeaderCell < TableCell
    attribute(String, :scope, :scope)
    attribute(String, :abbr, :abbr)
  end
  class TableHeaderCellCollection < ElementCollection
  end

  class TableDataCell < TableCell
  end
  class TableDataCellCollection < ElementCollection
  end

  class TableRow < HTMLElement
    attribute(Integer, :rowindex, :rowIndex)
    attribute(Integer, :sectionrowindex, :sectionRowIndex)
    attribute(String, :align, :align)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute(String, :valign, :vAlign)
    attribute(String, :bgcolor, :bgColor)
  end
  class TableRowCollection < ElementCollection
  end

  class TableSection < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute(String, :valign, :vAlign)
  end
  class TableSectionCollection < ElementCollection
  end

  class TableCol < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute(String, :valign, :vAlign)
  end
  class TableColCollection < ElementCollection
  end

  class TableCaption < HTMLElement
    attribute(String, :align, :align)
  end
  class TableCaptionCollection < ElementCollection
  end

  class Table < HTMLElement
    attribute(String, :tbodies, :tBodies)
    attribute(String, :align, :align)
    attribute(String, :border, :border)
    attribute(String, :frame, :frame)
    attribute(String, :rules, :rules)
    attribute(String, :summary, :summary)
    attribute(String, :bgcolor, :bgColor)
    attribute(String, :cellpadding, :cellPadding)
    attribute(String, :cellspacing, :cellSpacing)
  end
  class TableCollection < ElementCollection
  end

  class Area < HTMLElement
    attribute(String, :alt, :alt)
    attribute(String, :coords, :coords)
    attribute(String, :shape, :shape)
    attribute(String, :target, :target)
    attribute(String, :download, :download)
    attribute(String, :rel, :rel)
    attribute(String, :rellist, :relList)
    attribute(String, :hreflang, :hreflang)
    attribute(String, :type, :type)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute("Boolean", :nohref?, :noHref)
    attribute(String, :href, :href)
    attribute(String, :origin, :origin)
    attribute(String, :protocol, :protocol)
    attribute(String, :username, :username)
    attribute(String, :password, :password)
    attribute(String, :host, :host)
    attribute(String, :hostname, :hostname)
    attribute(String, :port, :port)
    attribute(String, :pathname, :pathname)
    attribute(String, :search, :search)
  end
  class AreaCollection < ElementCollection
  end

  class Map < HTMLElement
    attribute(String, :name, :name)
    attribute(String, :areas, :areas)
    attribute(String, :images, :images)
  end
  class MapCollection < ElementCollection
  end

  class Media < HTMLElement
    attribute(String, :error, :error)
    attribute(String, :src, :src)
    attribute(String, :srcobject, :srcObject)
    attribute(String, :currentsrc, :currentSrc)
    attribute(String, :crossorigin, :crossOrigin)
    attribute(Integer, :networkstate, :networkState)
    attribute(String, :preload, :preload)
    attribute(String, :buffered, :buffered)
    attribute(Integer, :readystate, :readyState)
    attribute("Boolean", :seeking?, :seeking)
    attribute(Float, :currenttime, :currentTime)
    attribute(Float, :duration, :duration)
    attribute("Boolean", :paused?, :paused)
    attribute(Float, :defaultplaybackrate, :defaultPlaybackRate)
    attribute(Float, :playbackrate, :playbackRate)
    attribute(String, :played, :played)
    attribute(String, :seekable, :seekable)
    attribute("Boolean", :ended?, :ended)
    attribute("Boolean", :autoplay?, :autoplay)
    attribute("Boolean", :loop?, :loop)
    attribute("Boolean", :controls?, :controls)
    attribute(Float, :volume, :volume)
    attribute("Boolean", :muted?, :muted)
    attribute("Boolean", :defaultmuted?, :defaultMuted)
    attribute(String, :audiotracks, :audioTracks)
    attribute(String, :videotracks, :videoTracks)
    attribute(String, :texttracks, :textTracks)
  end
  class MediaCollection < ElementCollection
  end

  class Audio < Media
  end
  class AudioCollection < ElementCollection
  end

  class Video < Media
    attribute(Integer, :videowidth, :videoWidth)
    attribute(Integer, :videoheight, :videoHeight)
    attribute(String, :poster, :poster)
  end
  class VideoCollection < ElementCollection
  end

  class Track < HTMLElement
    attribute(String, :kind, :kind)
    attribute(String, :src, :src)
    attribute(String, :srclang, :srclang)
    attribute(String, :label, :label)
    attribute("Boolean", :default?, :default)
    attribute(Integer, :readystate, :readyState)
    attribute(String, :track, :track)
  end
  class TrackCollection < ElementCollection
  end

  class Param < HTMLElement
    attribute(String, :name, :name)
    attribute(String, :value, :value)
    attribute(String, :type, :type)
    attribute(String, :valuetype, :valueType)
  end
  class ParamCollection < ElementCollection
  end

  class Object < HTMLElement
    attribute(String, :data, :data)
    attribute(String, :type, :type)
    attribute("Boolean", :typemustmatch?, :typeMustMatch)
    attribute(String, :name, :name)
    attribute(String, :form, :form)
    attribute(String, :contentdocument, :contentDocument)
    attribute(String, :contentwindow, :contentWindow)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :align, :align)
    attribute(String, :archive, :archive)
    attribute(String, :code, :code)
    attribute("Boolean", :declare?, :declare)
    attribute(Integer, :hspace, :hspace)
    attribute(String, :standby, :standby)
    attribute(Integer, :vspace, :vspace)
    attribute(String, :codebase, :codeBase)
    attribute(String, :codetype, :codeType)
    attribute(String, :border, :border)
  end
  class ObjectCollection < ElementCollection
  end

  class Embed < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :type, :type)
    attribute(String, :align, :align)
    attribute(String, :name, :name)
  end
  class EmbedCollection < ElementCollection
  end

  class IFrame < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :srcdoc, :srcdoc)
    attribute(String, :name, :name)
    attribute(String, :sandbox, :sandbox)
    attribute("Boolean", :allowfullscreen?, :allowFullscreen)
    attribute("Boolean", :allowpaymentrequest?, :allowPaymentRequest)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute(String, :contentdocument, :contentDocument)
    attribute(String, :contentwindow, :contentWindow)
    attribute(String, :align, :align)
    attribute(String, :scrolling, :scrolling)
    attribute(String, :frameborder, :frameBorder)
    attribute(String, :longdesc, :longDesc)
    attribute(String, :marginheight, :marginHeight)
    attribute(String, :marginwidth, :marginWidth)
  end
  class IFrameCollection < ElementCollection
  end

  class Image < HTMLElement
    attribute(String, :alt, :alt)
    attribute(String, :src, :src)
    attribute(String, :srcset, :srcset)
    attribute(String, :sizes, :sizes)
    attribute(String, :crossorigin, :crossOrigin)
    attribute(String, :usemap, :useMap)
    attribute(String, :longdesc, :longDesc)
    attribute("Boolean", :ismap?, :isMap)
    attribute(Integer, :naturalwidth, :naturalWidth)
    attribute(Integer, :naturalheight, :naturalHeight)
    attribute("Boolean", :complete?, :complete)
    attribute(String, :currentsrc, :currentSrc)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute(String, :name, :name)
    attribute(String, :lowsrc, :lowsrc)
    attribute(String, :align, :align)
    attribute(Integer, :hspace, :hspace)
    attribute(Integer, :vspace, :vspace)
    attribute(String, :border, :border)
  end
  class ImageCollection < ElementCollection
  end

  class Source < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :type, :type)
    attribute(String, :srcset, :srcset)
    attribute(String, :sizes, :sizes)
    attribute(String, :media, :media)
  end
  class SourceCollection < ElementCollection
  end

  class Picture < HTMLElement
  end
  class PictureCollection < ElementCollection
  end

  class Mod < HTMLElement
    attribute(String, :cite, :cite)
    attribute(String, :datetime, :dateTime)
  end
  class ModCollection < ElementCollection
  end

  class BR < HTMLElement
    attribute(String, :clear, :clear)
  end
  class BRCollection < ElementCollection
  end

  class Span < HTMLElement
  end
  class SpanCollection < ElementCollection
  end

  class Time < HTMLElement
    attribute(String, :datetime, :dateTime)
  end
  class TimeCollection < ElementCollection
  end

  class Data < HTMLElement
    attribute(String, :value, :value)
  end
  class DataCollection < ElementCollection
  end

  class Anchor < HTMLElement
    attribute(String, :target, :target)
    attribute(String, :download, :download)
    attribute(String, :rel, :rel)
    attribute(String, :rev, :rev)
    attribute(String, :rellist, :relList)
    attribute(String, :hreflang, :hreflang)
    attribute(String, :type, :type)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute(String, :coords, :coords)
    attribute(String, :charset, :charset)
    attribute(String, :name, :name)
    attribute(String, :shape, :shape)
    attribute(String, :href, :href)
    attribute(String, :origin, :origin)
    attribute(String, :protocol, :protocol)
    attribute(String, :username, :username)
    attribute(String, :password, :password)
    attribute(String, :host, :host)
    attribute(String, :hostname, :hostname)
    attribute(String, :port, :port)
    attribute(String, :pathname, :pathname)
    attribute(String, :search, :search)
  end
  class AnchorCollection < ElementCollection
  end

  class Div < HTMLElement
    attribute(String, :align, :align)
  end
  class DivCollection < ElementCollection
  end

  class DList < HTMLElement
    attribute("Boolean", :compact?, :compact)
  end
  class DListCollection < ElementCollection
  end

  class LI < HTMLElement
    attribute(Integer, :value, :value)
    attribute(String, :type, :type)
  end
  class LICollection < ElementCollection
  end

  class UList < HTMLElement
    attribute("Boolean", :compact?, :compact)
    attribute(String, :type, :type)
  end
  class UListCollection < ElementCollection
  end

  class OList < HTMLElement
    attribute("Boolean", :reversed?, :reversed)
    attribute(Integer, :start, :start)
    attribute(String, :type, :type)
    attribute("Boolean", :compact?, :compact)
  end
  class OListCollection < ElementCollection
  end

  class Quote < HTMLElement
    attribute(String, :cite, :cite)
  end
  class QuoteCollection < ElementCollection
  end

  class Pre < HTMLElement
  end
  class PreCollection < ElementCollection
  end

  class HR < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :color, :color)
    attribute("Boolean", :noshade?, :noShade)
  end
  class HRCollection < ElementCollection
  end

  class Paragraph < HTMLElement
    attribute(String, :align, :align)
  end
  class ParagraphCollection < ElementCollection
  end

  class Heading < HTMLElement
    attribute(String, :align, :align)
  end
  class HeadingCollection < ElementCollection
  end

  class Body < HTMLElement
    attribute(String, :vlink, :vLink)
    attribute(String, :alink, :aLink)
    attribute(String, :bgcolor, :bgColor)
    attribute(String, :background, :background)
    attribute(String, :onafterprint, :onafterprint)
    attribute(String, :onbeforeprint, :onbeforeprint)
    attribute(String, :onbeforeunload, :onbeforeunload)
    attribute(String, :onhashchange, :onhashchange)
    attribute(String, :onlanguagechange, :onlanguagechange)
    attribute(String, :onmessage, :onmessage)
    attribute(String, :onoffline, :onoffline)
    attribute(String, :ononline, :ononline)
    attribute(String, :onpagehide, :onpagehide)
    attribute(String, :onpageshow, :onpageshow)
    attribute(String, :onrejectionhandled, :onrejectionhandled)
    attribute(String, :onpopstate, :onpopstate)
    attribute(String, :onstorage, :onstorage)
    attribute(String, :onunhandledrejection, :onunhandledrejection)
    attribute(String, :onunload, :onunload)
  end
  class BodyCollection < ElementCollection
  end

  class Style < HTMLElement
    attribute(String, :media, :media)
    attribute(String, :nonce, :nonce)
    attribute(String, :type, :type)
  end
  class StyleCollection < ElementCollection
  end

  class Meta < HTMLElement
    attribute(String, :name, :name)
    attribute(String, :http_equiv, :httpEquiv)
    attribute(String, :content, :content)
    attribute(String, :scheme, :scheme)
  end
  class MetaCollection < ElementCollection
  end

  class Base < HTMLElement
    attribute(String, :href, :href)
    attribute(String, :target, :target)
  end
  class BaseCollection < ElementCollection
  end

  class Title < HTMLElement
  end
  class TitleCollection < ElementCollection
  end

  class Head < HTMLElement
  end
  class HeadCollection < ElementCollection
  end

  class Html < HTMLElement
    attribute(String, :version, :version)
  end
  class HtmlCollection < ElementCollection
  end

  class Unknown < HTMLElement
  end
  class UnknownCollection < ElementCollection
  end


  module Container

    # @return [Anchor]
    def a(opts = {})
      Anchor.new(self, opts.merge(tag_name: "a"))
    end
    # @return [AnchorCollection]
    def as(opts = {})
      AnchorCollection.new(self, opts.merge(tag_name: "a"))
    end
    Watir.tag_to_class[:a] = Anchor

    # @return [HTMLElement]
    def abbr(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "abbr"))
    end
    # @return [HTMLElementCollection]
    def abbrs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "abbr"))
    end
    Watir.tag_to_class[:abbr] = HTMLElement

    # @return [HTMLElement]
    def address(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "address"))
    end
    # @return [HTMLElementCollection]
    def addresses(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "address"))
    end
    Watir.tag_to_class[:address] = HTMLElement

    # @return [Area]
    def area(opts = {})
      Area.new(self, opts.merge(tag_name: "area"))
    end
    # @return [AreaCollection]
    def areas(opts = {})
      AreaCollection.new(self, opts.merge(tag_name: "area"))
    end
    Watir.tag_to_class[:area] = Area

    # @return [HTMLElement]
    def article(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "article"))
    end
    # @return [HTMLElementCollection]
    def articles(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "article"))
    end
    Watir.tag_to_class[:article] = HTMLElement

    # @return [HTMLElement]
    def aside(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "aside"))
    end
    # @return [HTMLElementCollection]
    def asides(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "aside"))
    end
    Watir.tag_to_class[:aside] = HTMLElement

    # @return [Audio]
    def audio(opts = {})
      Audio.new(self, opts.merge(tag_name: "audio"))
    end
    # @return [AudioCollection]
    def audios(opts = {})
      AudioCollection.new(self, opts.merge(tag_name: "audio"))
    end
    Watir.tag_to_class[:audio] = Audio

    # @return [HTMLElement]
    def b(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "b"))
    end
    # @return [HTMLElementCollection]
    def bs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "b"))
    end
    Watir.tag_to_class[:b] = HTMLElement

    # @return [Base]
    def base(opts = {})
      Base.new(self, opts.merge(tag_name: "base"))
    end
    # @return [BaseCollection]
    def bases(opts = {})
      BaseCollection.new(self, opts.merge(tag_name: "base"))
    end
    Watir.tag_to_class[:base] = Base

    # @return [HTMLElement]
    def bdi(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "bdi"))
    end
    # @return [HTMLElementCollection]
    def bdis(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "bdi"))
    end
    Watir.tag_to_class[:bdi] = HTMLElement

    # @return [HTMLElement]
    def bdo(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "bdo"))
    end
    # @return [HTMLElementCollection]
    def bdos(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "bdo"))
    end
    Watir.tag_to_class[:bdo] = HTMLElement

    # @return [Quote]
    def blockquote(opts = {})
      Quote.new(self, opts.merge(tag_name: "blockquote"))
    end
    # @return [QuoteCollection]
    def blockquotes(opts = {})
      QuoteCollection.new(self, opts.merge(tag_name: "blockquote"))
    end
    Watir.tag_to_class[:blockquote] = Quote

    # @return [Body]
    def body(opts = {})
      Body.new(self, opts.merge(tag_name: "body"))
    end
    # @return [BodyCollection]
    def bodys(opts = {})
      BodyCollection.new(self, opts.merge(tag_name: "body"))
    end
    Watir.tag_to_class[:body] = Body

    # @return [BR]
    def br(opts = {})
      BR.new(self, opts.merge(tag_name: "br"))
    end
    # @return [BRCollection]
    def brs(opts = {})
      BRCollection.new(self, opts.merge(tag_name: "br"))
    end
    Watir.tag_to_class[:br] = BR

    # @return [Button]
    def button(opts = {})
      Button.new(self, opts.merge(tag_name: "button"))
    end
    # @return [ButtonCollection]
    def buttons(opts = {})
      ButtonCollection.new(self, opts.merge(tag_name: "button"))
    end
    Watir.tag_to_class[:button] = Button

    # @return [Canvas]
    def canvas(opts = {})
      Canvas.new(self, opts.merge(tag_name: "canvas"))
    end
    # @return [CanvasCollection]
    def canvases(opts = {})
      CanvasCollection.new(self, opts.merge(tag_name: "canvas"))
    end
    Watir.tag_to_class[:canvas] = Canvas

    # @return [TableCaption]
    def caption(opts = {})
      TableCaption.new(self, opts.merge(tag_name: "caption"))
    end
    # @return [TableCaptionCollection]
    def captions(opts = {})
      TableCaptionCollection.new(self, opts.merge(tag_name: "caption"))
    end
    Watir.tag_to_class[:caption] = TableCaption

    # @return [HTMLElement]
    def cite(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "cite"))
    end
    # @return [HTMLElementCollection]
    def cites(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "cite"))
    end
    Watir.tag_to_class[:cite] = HTMLElement

    # @return [HTMLElement]
    def code(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "code"))
    end
    # @return [HTMLElementCollection]
    def codes(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "code"))
    end
    Watir.tag_to_class[:code] = HTMLElement

    # @return [TableCol]
    def col(opts = {})
      TableCol.new(self, opts.merge(tag_name: "col"))
    end
    # @return [TableColCollection]
    def cols(opts = {})
      TableColCollection.new(self, opts.merge(tag_name: "col"))
    end
    Watir.tag_to_class[:col] = TableCol

    # @return [TableCol]
    def colgroup(opts = {})
      TableCol.new(self, opts.merge(tag_name: "colgroup"))
    end
    # @return [TableColCollection]
    def colgroups(opts = {})
      TableColCollection.new(self, opts.merge(tag_name: "colgroup"))
    end
    Watir.tag_to_class[:colgroup] = TableCol

    # @return [Data]
    def data(opts = {})
      Data.new(self, opts.merge(tag_name: "data"))
    end
    # @return [DataCollection]
    def datas(opts = {})
      DataCollection.new(self, opts.merge(tag_name: "data"))
    end
    Watir.tag_to_class[:data] = Data

    # @return [DataList]
    def datalist(opts = {})
      DataList.new(self, opts.merge(tag_name: "datalist"))
    end
    # @return [DataListCollection]
    def datalists(opts = {})
      DataListCollection.new(self, opts.merge(tag_name: "datalist"))
    end
    Watir.tag_to_class[:datalist] = DataList

    # @return [HTMLElement]
    def dd(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "dd"))
    end
    # @return [HTMLElementCollection]
    def dds(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "dd"))
    end
    Watir.tag_to_class[:dd] = HTMLElement

    # @return [Mod]
    def del(opts = {})
      Mod.new(self, opts.merge(tag_name: "del"))
    end
    # @return [ModCollection]
    def dels(opts = {})
      ModCollection.new(self, opts.merge(tag_name: "del"))
    end
    Watir.tag_to_class[:del] = Mod

    # @return [Details]
    def details(opts = {})
      Details.new(self, opts.merge(tag_name: "details"))
    end
    # @return [DetailsCollection]
    def detailses(opts = {})
      DetailsCollection.new(self, opts.merge(tag_name: "details"))
    end
    Watir.tag_to_class[:details] = Details

    # @return [HTMLElement]
    def dfn(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "dfn"))
    end
    # @return [HTMLElementCollection]
    def dfns(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "dfn"))
    end
    Watir.tag_to_class[:dfn] = HTMLElement

    # @return [Dialog]
    def dialog(opts = {})
      Dialog.new(self, opts.merge(tag_name: "dialog"))
    end
    # @return [DialogCollection]
    def dialogs(opts = {})
      DialogCollection.new(self, opts.merge(tag_name: "dialog"))
    end
    Watir.tag_to_class[:dialog] = Dialog

    # @return [Div]
    def div(opts = {})
      Div.new(self, opts.merge(tag_name: "div"))
    end
    # @return [DivCollection]
    def divs(opts = {})
      DivCollection.new(self, opts.merge(tag_name: "div"))
    end
    Watir.tag_to_class[:div] = Div

    # @return [DList]
    def dl(opts = {})
      DList.new(self, opts.merge(tag_name: "dl"))
    end
    # @return [DListCollection]
    def dls(opts = {})
      DListCollection.new(self, opts.merge(tag_name: "dl"))
    end
    Watir.tag_to_class[:dl] = DList

    # @return [HTMLElement]
    def dt(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "dt"))
    end
    # @return [HTMLElementCollection]
    def dts(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "dt"))
    end
    Watir.tag_to_class[:dt] = HTMLElement

    # @return [HTMLElement]
    def em(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "em"))
    end
    # @return [HTMLElementCollection]
    def ems(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "em"))
    end
    Watir.tag_to_class[:em] = HTMLElement

    # @return [Embed]
    def embed(opts = {})
      Embed.new(self, opts.merge(tag_name: "embed"))
    end
    # @return [EmbedCollection]
    def embeds(opts = {})
      EmbedCollection.new(self, opts.merge(tag_name: "embed"))
    end
    Watir.tag_to_class[:embed] = Embed

    # @return [FieldSet]
    def fieldset(opts = {})
      FieldSet.new(self, opts.merge(tag_name: "fieldset"))
    end
    # @return [FieldSetCollection]
    def fieldsets(opts = {})
      FieldSetCollection.new(self, opts.merge(tag_name: "fieldset"))
    end
    Watir.tag_to_class[:fieldset] = FieldSet

    # @return [HTMLElement]
    def figcaption(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "figcaption"))
    end
    # @return [HTMLElementCollection]
    def figcaptions(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "figcaption"))
    end
    Watir.tag_to_class[:figcaption] = HTMLElement

    # @return [HTMLElement]
    def figure(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "figure"))
    end
    # @return [HTMLElementCollection]
    def figures(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "figure"))
    end
    Watir.tag_to_class[:figure] = HTMLElement

    # @return [HTMLElement]
    def footer(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "footer"))
    end
    # @return [HTMLElementCollection]
    def footers(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "footer"))
    end
    Watir.tag_to_class[:footer] = HTMLElement

    # @return [Form]
    def form(opts = {})
      Form.new(self, opts.merge(tag_name: "form"))
    end
    # @return [FormCollection]
    def forms(opts = {})
      FormCollection.new(self, opts.merge(tag_name: "form"))
    end
    Watir.tag_to_class[:form] = Form

    # @return [FrameSet]
    def frameset(opts = {})
      FrameSet.new(self, opts.merge(tag_name: "frameset"))
    end
    # @return [FrameSetCollection]
    def framesets(opts = {})
      FrameSetCollection.new(self, opts.merge(tag_name: "frameset"))
    end
    Watir.tag_to_class[:frameset] = FrameSet

    # @return [Heading]
    def h1(opts = {})
      Heading.new(self, opts.merge(tag_name: "h1"))
    end
    # @return [HeadingCollection]
    def h1s(opts = {})
      HeadingCollection.new(self, opts.merge(tag_name: "h1"))
    end
    Watir.tag_to_class[:h1] = Heading

    # @return [Heading]
    def h2(opts = {})
      Heading.new(self, opts.merge(tag_name: "h2"))
    end
    # @return [HeadingCollection]
    def h2s(opts = {})
      HeadingCollection.new(self, opts.merge(tag_name: "h2"))
    end
    Watir.tag_to_class[:h2] = Heading

    # @return [Heading]
    def h3(opts = {})
      Heading.new(self, opts.merge(tag_name: "h3"))
    end
    # @return [HeadingCollection]
    def h3s(opts = {})
      HeadingCollection.new(self, opts.merge(tag_name: "h3"))
    end
    Watir.tag_to_class[:h3] = Heading

    # @return [Heading]
    def h4(opts = {})
      Heading.new(self, opts.merge(tag_name: "h4"))
    end
    # @return [HeadingCollection]
    def h4s(opts = {})
      HeadingCollection.new(self, opts.merge(tag_name: "h4"))
    end
    Watir.tag_to_class[:h4] = Heading

    # @return [Heading]
    def h5(opts = {})
      Heading.new(self, opts.merge(tag_name: "h5"))
    end
    # @return [HeadingCollection]
    def h5s(opts = {})
      HeadingCollection.new(self, opts.merge(tag_name: "h5"))
    end
    Watir.tag_to_class[:h5] = Heading

    # @return [Heading]
    def h6(opts = {})
      Heading.new(self, opts.merge(tag_name: "h6"))
    end
    # @return [HeadingCollection]
    def h6s(opts = {})
      HeadingCollection.new(self, opts.merge(tag_name: "h6"))
    end
    Watir.tag_to_class[:h6] = Heading

    # @return [Head]
    def head(opts = {})
      Head.new(self, opts.merge(tag_name: "head"))
    end
    # @return [HeadCollection]
    def heads(opts = {})
      HeadCollection.new(self, opts.merge(tag_name: "head"))
    end
    Watir.tag_to_class[:head] = Head

    # @return [HTMLElement]
    def header(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "header"))
    end
    # @return [HTMLElementCollection]
    def headers(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "header"))
    end
    Watir.tag_to_class[:header] = HTMLElement

    # @return [HR]
    def hr(opts = {})
      HR.new(self, opts.merge(tag_name: "hr"))
    end
    # @return [HRCollection]
    def hrs(opts = {})
      HRCollection.new(self, opts.merge(tag_name: "hr"))
    end
    Watir.tag_to_class[:hr] = HR

    # @return [Html]
    def html(opts = {})
      Html.new(self, opts.merge(tag_name: "html"))
    end
    # @return [HtmlCollection]
    def htmls(opts = {})
      HtmlCollection.new(self, opts.merge(tag_name: "html"))
    end
    Watir.tag_to_class[:html] = Html

    # @return [HTMLElement]
    def i(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "i"))
    end
    # @return [HTMLElementCollection]
    def is(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "i"))
    end
    Watir.tag_to_class[:i] = HTMLElement

    # @return [IFrame]
    def iframe(opts = {})
      IFrame.new(self, opts.merge(tag_name: "iframe"))
    end
    # @return [IFrameCollection]
    def iframes(opts = {})
      IFrameCollection.new(self, opts.merge(tag_name: "iframe"))
    end
    Watir.tag_to_class[:iframe] = IFrame

    # @return [Image]
    def img(opts = {})
      Image.new(self, opts.merge(tag_name: "img"))
    end
    # @return [ImageCollection]
    def imgs(opts = {})
      ImageCollection.new(self, opts.merge(tag_name: "img"))
    end
    Watir.tag_to_class[:img] = Image

    # @return [Input]
    def input(opts = {})
      Input.new(self, opts.merge(tag_name: "input"))
    end
    # @return [InputCollection]
    def inputs(opts = {})
      InputCollection.new(self, opts.merge(tag_name: "input"))
    end
    Watir.tag_to_class[:input] = Input

    # @return [Mod]
    def ins(opts = {})
      Mod.new(self, opts.merge(tag_name: "ins"))
    end
    # @return [ModCollection]
    def inses(opts = {})
      ModCollection.new(self, opts.merge(tag_name: "ins"))
    end
    Watir.tag_to_class[:ins] = Mod

    # @return [HTMLElement]
    def kbd(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "kbd"))
    end
    # @return [HTMLElementCollection]
    def kbds(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "kbd"))
    end
    Watir.tag_to_class[:kbd] = HTMLElement

    # @return [Label]
    def label(opts = {})
      Label.new(self, opts.merge(tag_name: "label"))
    end
    # @return [LabelCollection]
    def labels(opts = {})
      LabelCollection.new(self, opts.merge(tag_name: "label"))
    end
    Watir.tag_to_class[:label] = Label

    # @return [Legend]
    def legend(opts = {})
      Legend.new(self, opts.merge(tag_name: "legend"))
    end
    # @return [LegendCollection]
    def legends(opts = {})
      LegendCollection.new(self, opts.merge(tag_name: "legend"))
    end
    Watir.tag_to_class[:legend] = Legend

    # @return [LI]
    def li(opts = {})
      LI.new(self, opts.merge(tag_name: "li"))
    end
    # @return [LICollection]
    def lis(opts = {})
      LICollection.new(self, opts.merge(tag_name: "li"))
    end
    Watir.tag_to_class[:li] = LI

    # @return [HTMLElement]
    def main(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "main"))
    end
    # @return [HTMLElementCollection]
    def mains(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "main"))
    end
    Watir.tag_to_class[:main] = HTMLElement

    # @return [Map]
    def map(opts = {})
      Map.new(self, opts.merge(tag_name: "map"))
    end
    # @return [MapCollection]
    def maps(opts = {})
      MapCollection.new(self, opts.merge(tag_name: "map"))
    end
    Watir.tag_to_class[:map] = Map

    # @return [HTMLElement]
    def mark(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "mark"))
    end
    # @return [HTMLElementCollection]
    def marks(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "mark"))
    end
    Watir.tag_to_class[:mark] = HTMLElement

    # @return [Meta]
    def meta(opts = {})
      Meta.new(self, opts.merge(tag_name: "meta"))
    end
    # @return [MetaCollection]
    def metas(opts = {})
      MetaCollection.new(self, opts.merge(tag_name: "meta"))
    end
    Watir.tag_to_class[:meta] = Meta

    # @return [Meter]
    def meter(opts = {})
      Meter.new(self, opts.merge(tag_name: "meter"))
    end
    # @return [MeterCollection]
    def meters(opts = {})
      MeterCollection.new(self, opts.merge(tag_name: "meter"))
    end
    Watir.tag_to_class[:meter] = Meter

    # @return [HTMLElement]
    def nav(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "nav"))
    end
    # @return [HTMLElementCollection]
    def navs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "nav"))
    end
    Watir.tag_to_class[:nav] = HTMLElement

    # @return [HTMLElement]
    def noscript(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "noscript"))
    end
    # @return [HTMLElementCollection]
    def noscripts(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "noscript"))
    end
    Watir.tag_to_class[:noscript] = HTMLElement

    # @return [Object]
    def object(opts = {})
      Object.new(self, opts.merge(tag_name: "object"))
    end
    # @return [ObjectCollection]
    def objects(opts = {})
      ObjectCollection.new(self, opts.merge(tag_name: "object"))
    end
    Watir.tag_to_class[:object] = Object

    # @return [OList]
    def ol(opts = {})
      OList.new(self, opts.merge(tag_name: "ol"))
    end
    # @return [OListCollection]
    def ols(opts = {})
      OListCollection.new(self, opts.merge(tag_name: "ol"))
    end
    Watir.tag_to_class[:ol] = OList

    # @return [OptGroup]
    def optgroup(opts = {})
      OptGroup.new(self, opts.merge(tag_name: "optgroup"))
    end
    # @return [OptGroupCollection]
    def optgroups(opts = {})
      OptGroupCollection.new(self, opts.merge(tag_name: "optgroup"))
    end
    Watir.tag_to_class[:optgroup] = OptGroup

    # @return [Option]
    def option(opts = {})
      Option.new(self, opts.merge(tag_name: "option"))
    end
    # @return [OptionCollection]
    def options(opts = {})
      OptionCollection.new(self, opts.merge(tag_name: "option"))
    end
    Watir.tag_to_class[:option] = Option

    # @return [Output]
    def output(opts = {})
      Output.new(self, opts.merge(tag_name: "output"))
    end
    # @return [OutputCollection]
    def outputs(opts = {})
      OutputCollection.new(self, opts.merge(tag_name: "output"))
    end
    Watir.tag_to_class[:output] = Output

    # @return [Paragraph]
    def p(opts = {})
      Paragraph.new(self, opts.merge(tag_name: "p"))
    end
    # @return [ParagraphCollection]
    def ps(opts = {})
      ParagraphCollection.new(self, opts.merge(tag_name: "p"))
    end
    Watir.tag_to_class[:p] = Paragraph

    # @return [Param]
    def param(opts = {})
      Param.new(self, opts.merge(tag_name: "param"))
    end
    # @return [ParamCollection]
    def params(opts = {})
      ParamCollection.new(self, opts.merge(tag_name: "param"))
    end
    Watir.tag_to_class[:param] = Param

    # @return [Picture]
    def picture(opts = {})
      Picture.new(self, opts.merge(tag_name: "picture"))
    end
    # @return [PictureCollection]
    def pictures(opts = {})
      PictureCollection.new(self, opts.merge(tag_name: "picture"))
    end
    Watir.tag_to_class[:picture] = Picture

    # @return [Pre]
    def pre(opts = {})
      Pre.new(self, opts.merge(tag_name: "pre"))
    end
    # @return [PreCollection]
    def pres(opts = {})
      PreCollection.new(self, opts.merge(tag_name: "pre"))
    end
    Watir.tag_to_class[:pre] = Pre

    # @return [Progress]
    def progress(opts = {})
      Progress.new(self, opts.merge(tag_name: "progress"))
    end
    # @return [ProgressCollection]
    def progresses(opts = {})
      ProgressCollection.new(self, opts.merge(tag_name: "progress"))
    end
    Watir.tag_to_class[:progress] = Progress

    # @return [Quote]
    def q(opts = {})
      Quote.new(self, opts.merge(tag_name: "q"))
    end
    # @return [QuoteCollection]
    def qs(opts = {})
      QuoteCollection.new(self, opts.merge(tag_name: "q"))
    end
    Watir.tag_to_class[:q] = Quote

    # @return [HTMLElement]
    def rb(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "rb"))
    end
    # @return [HTMLElementCollection]
    def rbs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "rb"))
    end
    Watir.tag_to_class[:rb] = HTMLElement

    # @return [HTMLElement]
    def rp(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "rp"))
    end
    # @return [HTMLElementCollection]
    def rps(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "rp"))
    end
    Watir.tag_to_class[:rp] = HTMLElement

    # @return [HTMLElement]
    def rt(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "rt"))
    end
    # @return [HTMLElementCollection]
    def rts(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "rt"))
    end
    Watir.tag_to_class[:rt] = HTMLElement

    # @return [HTMLElement]
    def rtc(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "rtc"))
    end
    # @return [HTMLElementCollection]
    def rtcs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "rtc"))
    end
    Watir.tag_to_class[:rtc] = HTMLElement

    # @return [HTMLElement]
    def ruby(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "ruby"))
    end
    # @return [HTMLElementCollection]
    def rubies(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "ruby"))
    end
    Watir.tag_to_class[:ruby] = HTMLElement

    # @return [HTMLElement]
    def s(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "s"))
    end
    # @return [HTMLElementCollection]
    def ss(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "s"))
    end
    Watir.tag_to_class[:s] = HTMLElement

    # @return [HTMLElement]
    def samp(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "samp"))
    end
    # @return [HTMLElementCollection]
    def samps(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "samp"))
    end
    Watir.tag_to_class[:samp] = HTMLElement

    # @return [Script]
    def script(opts = {})
      Script.new(self, opts.merge(tag_name: "script"))
    end
    # @return [ScriptCollection]
    def scripts(opts = {})
      ScriptCollection.new(self, opts.merge(tag_name: "script"))
    end
    Watir.tag_to_class[:script] = Script

    # @return [HTMLElement]
    def section(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "section"))
    end
    # @return [HTMLElementCollection]
    def sections(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "section"))
    end
    Watir.tag_to_class[:section] = HTMLElement

    # @return [Select]
    def select(opts = {})
      Select.new(self, opts.merge(tag_name: "select"))
    end
    # @return [SelectCollection]
    def selects(opts = {})
      SelectCollection.new(self, opts.merge(tag_name: "select"))
    end
    Watir.tag_to_class[:select] = Select

    # @return [HTMLElement]
    def small(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "small"))
    end
    # @return [HTMLElementCollection]
    def smalls(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "small"))
    end
    Watir.tag_to_class[:small] = HTMLElement

    # @return [Source]
    def source(opts = {})
      Source.new(self, opts.merge(tag_name: "source"))
    end
    # @return [SourceCollection]
    def sources(opts = {})
      SourceCollection.new(self, opts.merge(tag_name: "source"))
    end
    Watir.tag_to_class[:source] = Source

    # @return [Span]
    def span(opts = {})
      Span.new(self, opts.merge(tag_name: "span"))
    end
    # @return [SpanCollection]
    def spans(opts = {})
      SpanCollection.new(self, opts.merge(tag_name: "span"))
    end
    Watir.tag_to_class[:span] = Span

    # @return [HTMLElement]
    def strong(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "strong"))
    end
    # @return [HTMLElementCollection]
    def strongs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "strong"))
    end
    Watir.tag_to_class[:strong] = HTMLElement

    # @return [Style]
    def style(opts = {})
      Style.new(self, opts.merge(tag_name: "style"))
    end
    # @return [StyleCollection]
    def styles(opts = {})
      StyleCollection.new(self, opts.merge(tag_name: "style"))
    end
    Watir.tag_to_class[:style] = Style

    # @return [HTMLElement]
    def sub(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "sub"))
    end
    # @return [HTMLElementCollection]
    def subs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "sub"))
    end
    Watir.tag_to_class[:sub] = HTMLElement

    # @return [HTMLElement]
    def summary(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "summary"))
    end
    # @return [HTMLElementCollection]
    def summaries(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "summary"))
    end
    Watir.tag_to_class[:summary] = HTMLElement

    # @return [HTMLElement]
    def sup(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "sup"))
    end
    # @return [HTMLElementCollection]
    def sups(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "sup"))
    end
    Watir.tag_to_class[:sup] = HTMLElement

    # @return [Table]
    def table(opts = {})
      Table.new(self, opts.merge(tag_name: "table"))
    end
    # @return [TableCollection]
    def tables(opts = {})
      TableCollection.new(self, opts.merge(tag_name: "table"))
    end
    Watir.tag_to_class[:table] = Table

    # @return [TableSection]
    def tbody(opts = {})
      TableSection.new(self, opts.merge(tag_name: "tbody"))
    end
    # @return [TableSectionCollection]
    def tbodys(opts = {})
      TableSectionCollection.new(self, opts.merge(tag_name: "tbody"))
    end
    Watir.tag_to_class[:tbody] = TableSection

    # @return [TableDataCell]
    def td(opts = {})
      TableDataCell.new(self, opts.merge(tag_name: "td"))
    end
    # @return [TableDataCellCollection]
    def tds(opts = {})
      TableDataCellCollection.new(self, opts.merge(tag_name: "td"))
    end
    Watir.tag_to_class[:td] = TableDataCell

    # @return [Template]
    def template(opts = {})
      Template.new(self, opts.merge(tag_name: "template"))
    end
    # @return [TemplateCollection]
    def templates(opts = {})
      TemplateCollection.new(self, opts.merge(tag_name: "template"))
    end
    Watir.tag_to_class[:template] = Template

    # @return [TextArea]
    def textarea(opts = {})
      TextArea.new(self, opts.merge(tag_name: "textarea"))
    end
    # @return [TextAreaCollection]
    def textareas(opts = {})
      TextAreaCollection.new(self, opts.merge(tag_name: "textarea"))
    end
    Watir.tag_to_class[:textarea] = TextArea

    # @return [TableSection]
    def tfoot(opts = {})
      TableSection.new(self, opts.merge(tag_name: "tfoot"))
    end
    # @return [TableSectionCollection]
    def tfoots(opts = {})
      TableSectionCollection.new(self, opts.merge(tag_name: "tfoot"))
    end
    Watir.tag_to_class[:tfoot] = TableSection

    # @return [TableHeaderCell]
    def th(opts = {})
      TableHeaderCell.new(self, opts.merge(tag_name: "th"))
    end
    # @return [TableHeaderCellCollection]
    def ths(opts = {})
      TableHeaderCellCollection.new(self, opts.merge(tag_name: "th"))
    end
    Watir.tag_to_class[:th] = TableHeaderCell

    # @return [TableSection]
    def thead(opts = {})
      TableSection.new(self, opts.merge(tag_name: "thead"))
    end
    # @return [TableSectionCollection]
    def theads(opts = {})
      TableSectionCollection.new(self, opts.merge(tag_name: "thead"))
    end
    Watir.tag_to_class[:thead] = TableSection

    # @return [Time]
    def time(opts = {})
      Time.new(self, opts.merge(tag_name: "time"))
    end
    # @return [TimeCollection]
    def times(opts = {})
      TimeCollection.new(self, opts.merge(tag_name: "time"))
    end
    Watir.tag_to_class[:time] = Time

    # @return [Title]
    def title(opts = {})
      Title.new(self, opts.merge(tag_name: "title"))
    end
    # @return [TitleCollection]
    def titles(opts = {})
      TitleCollection.new(self, opts.merge(tag_name: "title"))
    end
    Watir.tag_to_class[:title] = Title

    # @return [TableRow]
    def tr(opts = {})
      TableRow.new(self, opts.merge(tag_name: "tr"))
    end
    # @return [TableRowCollection]
    def trs(opts = {})
      TableRowCollection.new(self, opts.merge(tag_name: "tr"))
    end
    Watir.tag_to_class[:tr] = TableRow

    # @return [Track]
    def track(opts = {})
      Track.new(self, opts.merge(tag_name: "track"))
    end
    # @return [TrackCollection]
    def tracks(opts = {})
      TrackCollection.new(self, opts.merge(tag_name: "track"))
    end
    Watir.tag_to_class[:track] = Track

    # @return [HTMLElement]
    def u(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "u"))
    end
    # @return [HTMLElementCollection]
    def us(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "u"))
    end
    Watir.tag_to_class[:u] = HTMLElement

    # @return [UList]
    def ul(opts = {})
      UList.new(self, opts.merge(tag_name: "ul"))
    end
    # @return [UListCollection]
    def uls(opts = {})
      UListCollection.new(self, opts.merge(tag_name: "ul"))
    end
    Watir.tag_to_class[:ul] = UList

    # @return [HTMLElement]
    def var(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "var"))
    end
    # @return [HTMLElementCollection]
    def vars(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "var"))
    end
    Watir.tag_to_class[:var] = HTMLElement

    # @return [Video]
    def video(opts = {})
      Video.new(self, opts.merge(tag_name: "video"))
    end
    # @return [VideoCollection]
    def videos(opts = {})
      VideoCollection.new(self, opts.merge(tag_name: "video"))
    end
    Watir.tag_to_class[:video] = Video

    # @return [HTMLElement]
    def wbr(opts = {})
      HTMLElement.new(self, opts.merge(tag_name: "wbr"))
    end
    # @return [HTMLElementCollection]
    def wbrs(opts = {})
      HTMLElementCollection.new(self, opts.merge(tag_name: "wbr"))
    end
    Watir.tag_to_class[:wbr] = HTMLElement
  end # Container
end # Watir
