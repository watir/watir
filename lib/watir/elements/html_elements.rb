# Autogenerated from HTML specification. Edits may be lost.
module Watir
  class HTMLElement < Element
    attribute(String, :title, :title)
    attribute(String, :lang, :lang)
    attribute("Boolean", :translate?, :translate)
    attribute(String, :dir, :dir)
    attribute(String, :dataset, :dataset)
    attribute("Boolean", :hidden?, :hidden)
    attribute(Integer, :tabindex, :tabIndex)
    attribute(String, :accesskey, :accessKey)
    attribute("Boolean", :draggable?, :draggable)
    attribute("Boolean", :spellcheck?, :spellcheck)
    attribute(String, :innertext, :innerText)
    attribute(String, :onabort, :onabort)
    attribute(String, :onblur, :onblur)
    attribute(String, :oncancel, :oncancel)
    attribute(String, :oncanplay, :oncanplay)
    attribute(String, :oncanplaythrough, :oncanplaythrough)
    attribute(String, :onchange, :onchange)
    attribute(String, :onclick, :onclick)
    attribute(String, :onclose, :onclose)
    attribute(String, :oncuechange, :oncuechange)
    attribute(String, :ondblclick, :ondblclick)
    attribute(String, :ondrag, :ondrag)
    attribute(String, :ondragend, :ondragend)
    attribute(String, :ondragenter, :ondragenter)
    attribute(String, :ondragexit, :ondragexit)
    attribute(String, :ondragleave, :ondragleave)
    attribute(String, :ondragover, :ondragover)
    attribute(String, :ondragstart, :ondragstart)
    attribute(String, :ondrop, :ondrop)
    attribute(String, :ondurationchange, :ondurationchange)
    attribute(String, :onemptied, :onemptied)
    attribute(String, :onended, :onended)
    attribute(String, :onerror, :onerror)
    attribute(String, :onfocus, :onfocus)
    attribute(String, :oninput, :oninput)
    attribute(String, :oninvalid, :oninvalid)
    attribute(String, :onkeydown, :onkeydown)
    attribute(String, :onkeypress, :onkeypress)
    attribute(String, :onkeyup, :onkeyup)
    attribute(String, :onload, :onload)
    attribute(String, :onloadeddata, :onloadeddata)
    attribute(String, :onloadedmetadata, :onloadedmetadata)
    attribute(String, :onloadstart, :onloadstart)
    attribute(String, :onmousedown, :onmousedown)
    attribute(String, :onmouseenter, :onmouseenter)
    attribute(String, :onmouseleave, :onmouseleave)
    attribute(String, :onmousemove, :onmousemove)
    attribute(String, :onmouseout, :onmouseout)
    attribute(String, :onmouseover, :onmouseover)
    attribute(String, :onmouseup, :onmouseup)
    attribute(String, :onwheel, :onwheel)
    attribute(String, :onpause, :onpause)
    attribute(String, :onplay, :onplay)
    attribute(String, :onplaying, :onplaying)
    attribute(String, :onprogress, :onprogress)
    attribute(String, :onratechange, :onratechange)
    attribute(String, :onreset, :onreset)
    attribute(String, :onresize, :onresize)
    attribute(String, :onscroll, :onscroll)
    attribute(String, :onseeked, :onseeked)
    attribute(String, :onseeking, :onseeking)
    attribute(String, :onselect, :onselect)
    attribute(String, :onshow, :onshow)
    attribute(String, :onstalled, :onstalled)
    attribute(String, :onsubmit, :onsubmit)
    attribute(String, :onsuspend, :onsuspend)
    attribute(String, :ontimeupdate, :ontimeupdate)
    attribute(String, :ontoggle, :ontoggle)
    attribute(String, :onvolumechange, :onvolumechange)
    attribute(String, :onwaiting, :onwaiting)
    attribute(String, :oncopy, :oncopy)
    attribute(String, :oncut, :oncut)
    attribute(String, :onpaste, :onpaste)
    attribute(String, :content_editable, :contentEditable)
    attribute("Boolean", :content_editable?, :isContentEditable)
  end
  class HTMLElementCollection < ElementCollection
  end

  class Font < HTMLElement
    attribute(String, :color, :color)
    attribute(String, :face, :face)
  end
  class FontCollection < ElementCollection
  end

  class Directory < HTMLElement
    attribute("Boolean", :compact?, :compact)
  end
  class DirectoryCollection < ElementCollection
  end

  class FrameSet < HTMLElement
    attribute(String, :cols, :cols)
    attribute(String, :onafterprint, :onafterprint)
    attribute(String, :onbeforeprint, :onbeforeprint)
    attribute(String, :onbeforeunload, :onbeforeunload)
    attribute(String, :onhashchange, :onhashchange)
    attribute(String, :onlanguagechange, :onlanguagechange)
    attribute(String, :onmessage, :onmessage)
    attribute(String, :onoffline, :onoffline)
    attribute(String, :ononline, :ononline)
    attribute(String, :onpagehide, :onpagehide)
    attribute(String, :onpageshow, :onpageshow)
    attribute(String, :onrejectionhandled, :onrejectionhandled)
    attribute(String, :onpopstate, :onpopstate)
    attribute(String, :onstorage, :onstorage)
    attribute(String, :onunhandledrejection, :onunhandledrejection)
    attribute(String, :onunload, :onunload)
  end
  class FrameSetCollection < ElementCollection
  end

  class Marquee < HTMLElement
    attribute(String, :behavior, :behavior)
    attribute(String, :bgcolor, :bgColor)
    attribute(String, :direction, :direction)
    attribute(Integer, :hspace, :hspace)
    attribute(Integer, :loop, :loop)
    attribute(Integer, :scrollamount, :scrollAmount)
    attribute(Integer, :scrolldelay, :scrollDelay)
    attribute("Boolean", :truespeed?, :trueSpeed)
    attribute(Integer, :vspace, :vspace)
    attribute(String, :onbounce, :onbounce)
    attribute(String, :onfinish, :onfinish)
    attribute(String, :onstart, :onstart)
  end
  class MarqueeCollection < ElementCollection
  end

  class Applet < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :alt, :alt)
    attribute(String, :archive, :archive)
    attribute(String, :code, :code)
    attribute(String, :codebase, :codeBase)
    attribute(Integer, :hspace, :hspace)
    attribute(String, :name, :name)
    attribute(String, :object, :object)
    attribute(Integer, :vspace, :vspace)
  end
  class AppletCollection < ElementCollection
  end

  class Canvas < HTMLElement
  end
  class CanvasCollection < ElementCollection
  end

  class Template < HTMLElement
    attribute(String, :content, :content)
  end
  class TemplateCollection < ElementCollection
  end

  class Script < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :type, :type)
    attribute(String, :charset, :charset)
    attribute("Boolean", :async?, :async)
    attribute("Boolean", :defer?, :defer)
    attribute(String, :crossorigin, :crossOrigin)
    attribute(String, :nonce, :nonce)
    attribute(String, :event, :event)
    attribute(String, :for, :htmlFor)
  end
  class ScriptCollection < ElementCollection
  end

  class Dialog < HTMLElement
    attribute("Boolean", :open?, :open)
    attribute(String, :returnvalue, :returnValue)
  end
  class DialogCollection < ElementCollection
  end

  class Details < HTMLElement
    attribute("Boolean", :open?, :open)
  end
  class DetailsCollection < ElementCollection
  end

  class Legend < HTMLElement
    attribute(String, :form, :form)
    attribute(String, :align, :align)
  end
  class LegendCollection < ElementCollection
  end

  class FieldSet < HTMLElement
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :name, :name)
    attribute(String, :type, :type)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
  end
  class FieldSetCollection < ElementCollection
  end

  class Meter < HTMLElement
    attribute(Float, :value, :value)
    attribute(Float, :min, :min)
    attribute(Float, :max, :max)
    attribute(Float, :low, :low)
    attribute(Float, :high, :high)
    attribute(Float, :optimum, :optimum)
    attribute(String, :labels, :labels)
  end
  class MeterCollection < ElementCollection
  end

  class Progress < HTMLElement
    attribute(Float, :value, :value)
    attribute(Float, :max, :max)
    attribute(Float, :position, :position)
    attribute(String, :labels, :labels)
  end
  class ProgressCollection < ElementCollection
  end

  class Output < HTMLElement
    attribute(String, :for, :htmlFor)
    attribute(String, :form, :form)
    attribute(String, :name, :name)
    attribute(String, :type, :type)
    attribute(String, :defaultvalue, :defaultValue)
    attribute(String, :value, :value)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
  end
  class OutputCollection < ElementCollection
  end

  class TextArea < HTMLElement
    attribute(String, :autocomplete, :autocomplete)
    attribute("Boolean", :autofocus?, :autofocus)
    attribute(Integer, :cols, :cols)
    attribute(String, :dirname, :dirName)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(Integer, :maxlength, :maxLength)
    attribute(Integer, :minlength, :minLength)
    attribute(String, :name, :name)
    attribute(String, :placeholder, :placeholder)
    attribute("Boolean", :readonly?, :readOnly)
    attribute("Boolean", :required?, :required)
    attribute(String, :wrap, :wrap)
    attribute(String, :type, :type)
    attribute(String, :defaultvalue, :defaultValue)
    attribute(String, :value, :value)
    attribute(Integer, :textlength, :textLength)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
    attribute(Integer, :selectionstart, :selectionStart)
    attribute(Integer, :selectionend, :selectionEnd)
    attribute(String, :selectiondirection, :selectionDirection)
  end
  class TextAreaCollection < ElementCollection
  end

  class Option < HTMLElement
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :label, :label)
    attribute("Boolean", :defaultselected?, :defaultSelected)
    attribute("Boolean", :selected?, :selected)
    attribute(String, :value, :value)
    attribute(Integer, :index, :index)
  end
  class OptionCollection < ElementCollection
  end

  class OptGroup < HTMLElement
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :label, :label)
  end
  class OptGroupCollection < ElementCollection
  end

  class DataList < HTMLElement
  end
  class DataListCollection < ElementCollection
  end

  class Select < HTMLElement
    attribute(String, :autocomplete, :autocomplete)
    attribute("Boolean", :autofocus?, :autofocus)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute("Boolean", :multiple?, :multiple)
    attribute(String, :name, :name)
    attribute("Boolean", :required?, :required)
    attribute(String, :type, :type)
    attribute(Integer, :length, :length)
    attribute(String, :selectedoptions, :selectedOptions)
    attribute(Integer, :selectedindex, :selectedIndex)
    attribute(String, :value, :value)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
  end
  class SelectCollection < ElementCollection
  end

  class Button < HTMLElement
    attribute("Boolean", :autofocus?, :autofocus)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :formaction, :formAction)
    attribute(String, :formenctype, :formEnctype)
    attribute(String, :formmethod, :formMethod)
    attribute("Boolean", :formnovalidate?, :formNoValidate)
    attribute(String, :formtarget, :formTarget)
    attribute(String, :name, :name)
    attribute(String, :type, :type)
    attribute(String, :value, :value)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
  end
  class ButtonCollection < ElementCollection
  end

  class Input < HTMLElement
    attribute(String, :accept, :accept)
    attribute(String, :alt, :alt)
    attribute(String, :autocomplete, :autocomplete)
    attribute("Boolean", :autofocus?, :autofocus)
    attribute("Boolean", :defaultchecked?, :defaultChecked)
    attribute("Boolean", :checked?, :checked)
    attribute(String, :dirname, :dirName)
    attribute("Boolean", :disabled?, :disabled)
    attribute(String, :form, :form)
    attribute(String, :files, :files)
    attribute(String, :formaction, :formAction)
    attribute(String, :formenctype, :formEnctype)
    attribute(String, :formmethod, :formMethod)
    attribute("Boolean", :formnovalidate?, :formNoValidate)
    attribute(String, :formtarget, :formTarget)
    attribute("Boolean", :indeterminate?, :indeterminate)
    attribute(String, :list, :list)
    attribute(String, :max, :max)
    attribute(Integer, :maxlength, :maxLength)
    attribute(String, :min, :min)
    attribute(Integer, :minlength, :minLength)
    attribute("Boolean", :multiple?, :multiple)
    attribute(String, :name, :name)
    attribute(String, :pattern, :pattern)
    attribute(String, :placeholder, :placeholder)
    attribute("Boolean", :readonly?, :readOnly)
    attribute("Boolean", :required?, :required)
    attribute(String, :src, :src)
    attribute(String, :step, :step)
    attribute(String, :type, :type)
    attribute(String, :defaultvalue, :defaultValue)
    attribute(String, :value, :value)
    attribute(String, :valueasdate, :valueAsDate)
    attribute(Float, :valueasnumber, :valueAsNumber)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :labels, :labels)
    attribute(Integer, :selectionstart, :selectionStart)
    attribute(Integer, :selectionend, :selectionEnd)
    attribute(String, :selectiondirection, :selectionDirection)
    attribute(String, :align, :align)
    attribute(String, :usemap, :useMap)
  end
  class InputCollection < ElementCollection
  end

  class Label < HTMLElement
    attribute(String, :form, :form)
    attribute(String, :for, :htmlFor)
    attribute(String, :control, :control)
  end
  class LabelCollection < ElementCollection
  end

  class Form < HTMLElement
    attribute(String, :accept_charset, :acceptCharset)
    attribute(String, :action, :action)
    attribute(String, :autocomplete, :autocomplete)
    attribute(String, :enctype, :enctype)
    attribute(String, :encoding, :encoding)
    attribute(String, :method, :method)
    attribute(String, :name, :name)
    attribute("Boolean", :novalidate?, :noValidate)
    attribute(String, :target, :target)
    attribute(Integer, :length, :length)
  end
  class FormCollection < ElementCollection
  end

  class TableCell < HTMLElement
    attribute(Integer, :colspan, :colSpan)
    attribute(Integer, :rowspan, :rowSpan)
    attribute(String, :headers, :headers)
    attribute(Integer, :cellindex, :cellIndex)
    attribute(String, :align, :align)
    attribute(String, :axis, :axis)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute("Boolean", :nowrap?, :noWrap)
    attribute(String, :valign, :vAlign)
    attribute(String, :bgcolor, :bgColor)
  end
  class TableCellCollection < ElementCollection
  end

  class TableHeaderCell < TableCell
    attribute(String, :scope, :scope)
    attribute(String, :abbr, :abbr)
  end
  class TableHeaderCellCollection < ElementCollection
  end

  class TableDataCell < TableCell
  end
  class TableDataCellCollection < ElementCollection
  end

  class TableRow < HTMLElement
    attribute(Integer, :rowindex, :rowIndex)
    attribute(Integer, :sectionrowindex, :sectionRowIndex)
    attribute(String, :align, :align)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute(String, :valign, :vAlign)
    attribute(String, :bgcolor, :bgColor)
  end
  class TableRowCollection < ElementCollection
  end

  class TableSection < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute(String, :valign, :vAlign)
  end
  class TableSectionCollection < ElementCollection
  end

  class TableCol < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :ch, :ch)
    attribute(String, :choff, :chOff)
    attribute(String, :valign, :vAlign)
  end
  class TableColCollection < ElementCollection
  end

  class TableCaption < HTMLElement
    attribute(String, :align, :align)
  end
  class TableCaptionCollection < ElementCollection
  end

  class Table < HTMLElement
    attribute(String, :caption, :caption)
    attribute(String, :tbodies, :tBodies)
    attribute(String, :align, :align)
    attribute(String, :border, :border)
    attribute(String, :frame, :frame)
    attribute(String, :rules, :rules)
    attribute(String, :summary, :summary)
    attribute(String, :bgcolor, :bgColor)
    attribute(String, :cellpadding, :cellPadding)
    attribute(String, :cellspacing, :cellSpacing)
  end
  class TableCollection < ElementCollection
  end

  class Area < HTMLElement
    attribute(String, :alt, :alt)
    attribute(String, :coords, :coords)
    attribute(String, :shape, :shape)
    attribute(String, :target, :target)
    attribute(String, :download, :download)
    attribute(String, :rel, :rel)
    attribute(String, :rellist, :relList)
    attribute(String, :hreflang, :hreflang)
    attribute(String, :type, :type)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute("Boolean", :nohref?, :noHref)
    attribute(String, :href, :href)
    attribute(String, :origin, :origin)
    attribute(String, :protocol, :protocol)
    attribute(String, :username, :username)
    attribute(String, :password, :password)
    attribute(String, :host, :host)
    attribute(String, :hostname, :hostname)
    attribute(String, :port, :port)
    attribute(String, :pathname, :pathname)
    attribute(String, :search, :search)
  end
  class AreaCollection < ElementCollection
  end

  class Map < HTMLElement
    attribute(String, :name, :name)
    attribute(String, :areas, :areas)
    attribute(String, :images, :images)
  end
  class MapCollection < ElementCollection
  end

  class Media < HTMLElement
    attribute(String, :error, :error)
    attribute(String, :src, :src)
    attribute(String, :srcobject, :srcObject)
    attribute(String, :currentsrc, :currentSrc)
    attribute(String, :crossorigin, :crossOrigin)
    attribute(Integer, :networkstate, :networkState)
    attribute(String, :preload, :preload)
    attribute(String, :buffered, :buffered)
    attribute(Integer, :readystate, :readyState)
    attribute("Boolean", :seeking?, :seeking)
    attribute(Float, :currenttime, :currentTime)
    attribute(Float, :duration, :duration)
    attribute("Boolean", :paused?, :paused)
    attribute(Float, :defaultplaybackrate, :defaultPlaybackRate)
    attribute(Float, :playbackrate, :playbackRate)
    attribute(String, :played, :played)
    attribute(String, :seekable, :seekable)
    attribute("Boolean", :ended?, :ended)
    attribute("Boolean", :autoplay?, :autoplay)
    attribute("Boolean", :loop?, :loop)
    attribute("Boolean", :controls?, :controls)
    attribute(Float, :volume, :volume)
    attribute("Boolean", :muted?, :muted)
    attribute("Boolean", :defaultmuted?, :defaultMuted)
    attribute(String, :audiotracks, :audioTracks)
    attribute(String, :videotracks, :videoTracks)
    attribute(String, :texttracks, :textTracks)
  end
  class MediaCollection < ElementCollection
  end

  class Audio < Media
  end
  class AudioCollection < ElementCollection
  end

  class Video < Media
    attribute(Integer, :videowidth, :videoWidth)
    attribute(Integer, :videoheight, :videoHeight)
    attribute(String, :poster, :poster)
  end
  class VideoCollection < ElementCollection
  end

  class Track < HTMLElement
    attribute(String, :kind, :kind)
    attribute(String, :src, :src)
    attribute(String, :srclang, :srclang)
    attribute(String, :label, :label)
    attribute("Boolean", :default?, :default)
    attribute(Integer, :readystate, :readyState)
    attribute(String, :track, :track)
  end
  class TrackCollection < ElementCollection
  end

  class Param < HTMLElement
    attribute(String, :name, :name)
    attribute(String, :value, :value)
    attribute(String, :type, :type)
    attribute(String, :valuetype, :valueType)
  end
  class ParamCollection < ElementCollection
  end

  class Object < HTMLElement
    attribute(String, :data, :data)
    attribute(String, :type, :type)
    attribute("Boolean", :typemustmatch?, :typeMustMatch)
    attribute(String, :name, :name)
    attribute(String, :form, :form)
    attribute(String, :contentdocument, :contentDocument)
    attribute(String, :contentwindow, :contentWindow)
    attribute("Boolean", :willvalidate?, :willValidate)
    attribute(String, :validity, :validity)
    attribute(String, :validationmessage, :validationMessage)
    attribute(String, :align, :align)
    attribute(String, :archive, :archive)
    attribute(String, :code, :code)
    attribute("Boolean", :declare?, :declare)
    attribute(Integer, :hspace, :hspace)
    attribute(String, :standby, :standby)
    attribute(Integer, :vspace, :vspace)
    attribute(String, :codebase, :codeBase)
    attribute(String, :codetype, :codeType)
    attribute(String, :border, :border)
  end
  class ObjectCollection < ElementCollection
  end

  class Embed < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :type, :type)
    attribute(String, :align, :align)
    attribute(String, :name, :name)
  end
  class EmbedCollection < ElementCollection
  end

  class IFrame < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :srcdoc, :srcdoc)
    attribute(String, :name, :name)
    attribute(String, :sandbox, :sandbox)
    attribute("Boolean", :allowfullscreen?, :allowFullscreen)
    attribute("Boolean", :allowpaymentrequest?, :allowPaymentRequest)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute(String, :contentdocument, :contentDocument)
    attribute(String, :contentwindow, :contentWindow)
    attribute(String, :align, :align)
    attribute(String, :scrolling, :scrolling)
    attribute(String, :frameborder, :frameBorder)
    attribute(String, :longdesc, :longDesc)
    attribute(String, :marginheight, :marginHeight)
    attribute(String, :marginwidth, :marginWidth)
  end
  class IFrameCollection < ElementCollection
  end

  class Image < HTMLElement
    attribute(String, :alt, :alt)
    attribute(String, :src, :src)
    attribute(String, :srcset, :srcset)
    attribute(String, :sizes, :sizes)
    attribute(String, :crossorigin, :crossOrigin)
    attribute(String, :usemap, :useMap)
    attribute(String, :longdesc, :longDesc)
    attribute("Boolean", :ismap?, :isMap)
    attribute(Integer, :naturalwidth, :naturalWidth)
    attribute(Integer, :naturalheight, :naturalHeight)
    attribute("Boolean", :complete?, :complete)
    attribute(String, :currentsrc, :currentSrc)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute(String, :name, :name)
    attribute(String, :lowsrc, :lowsrc)
    attribute(String, :align, :align)
    attribute(Integer, :hspace, :hspace)
    attribute(Integer, :vspace, :vspace)
    attribute(String, :border, :border)
  end
  class ImageCollection < ElementCollection
  end

  class Source < HTMLElement
    attribute(String, :src, :src)
    attribute(String, :type, :type)
    attribute(String, :srcset, :srcset)
    attribute(String, :sizes, :sizes)
    attribute(String, :media, :media)
  end
  class SourceCollection < ElementCollection
  end

  class Picture < HTMLElement
  end
  class PictureCollection < ElementCollection
  end

  class Mod < HTMLElement
    attribute(String, :cite, :cite)
    attribute(String, :datetime, :dateTime)
  end
  class ModCollection < ElementCollection
  end

  class BR < HTMLElement
    attribute(String, :clear, :clear)
  end
  class BRCollection < ElementCollection
  end

  class Span < HTMLElement
  end
  class SpanCollection < ElementCollection
  end

  class Time < HTMLElement
    attribute(String, :datetime, :dateTime)
  end
  class TimeCollection < ElementCollection
  end

  class Data < HTMLElement
    attribute(String, :value, :value)
  end
  class DataCollection < ElementCollection
  end

  class Anchor < HTMLElement
    attribute(String, :target, :target)
    attribute(String, :download, :download)
    attribute(String, :rel, :rel)
    attribute(String, :rev, :rev)
    attribute(String, :rellist, :relList)
    attribute(String, :hreflang, :hreflang)
    attribute(String, :type, :type)
    attribute(String, :referrerpolicy, :referrerPolicy)
    attribute(String, :coords, :coords)
    attribute(String, :charset, :charset)
    attribute(String, :name, :name)
    attribute(String, :shape, :shape)
    attribute(String, :href, :href)
    attribute(String, :origin, :origin)
    attribute(String, :protocol, :protocol)
    attribute(String, :username, :username)
    attribute(String, :password, :password)
    attribute(String, :host, :host)
    attribute(String, :hostname, :hostname)
    attribute(String, :port, :port)
    attribute(String, :pathname, :pathname)
    attribute(String, :search, :search)
  end
  class AnchorCollection < ElementCollection
  end

  class Div < HTMLElement
    attribute(String, :align, :align)
  end
  class DivCollection < ElementCollection
  end

  class DList < HTMLElement
    attribute("Boolean", :compact?, :compact)
  end
  class DListCollection < ElementCollection
  end

  class LI < HTMLElement
    attribute(Integer, :value, :value)
    attribute(String, :type, :type)
  end
  class LICollection < ElementCollection
  end

  class UList < HTMLElement
    attribute("Boolean", :compact?, :compact)
    attribute(String, :type, :type)
  end
  class UListCollection < ElementCollection
  end

  class OList < HTMLElement
    attribute("Boolean", :reversed?, :reversed)
    attribute(Integer, :start, :start)
    attribute(String, :type, :type)
    attribute("Boolean", :compact?, :compact)
  end
  class OListCollection < ElementCollection
  end

  class Quote < HTMLElement
    attribute(String, :cite, :cite)
  end
  class QuoteCollection < ElementCollection
  end

  class Pre < HTMLElement
  end
  class PreCollection < ElementCollection
  end

  class HR < HTMLElement
    attribute(String, :align, :align)
    attribute(String, :color, :color)
    attribute("Boolean", :noshade?, :noShade)
  end
  class HRCollection < ElementCollection
  end

  class Paragraph < HTMLElement
    attribute(String, :align, :align)
  end
  class ParagraphCollection < ElementCollection
  end

  class Heading < HTMLElement
    attribute(String, :align, :align)
  end
  class HeadingCollection < ElementCollection
  end

  class Body < HTMLElement
    attribute(String, :vlink, :vLink)
    attribute(String, :alink, :aLink)
    attribute(String, :bgcolor, :bgColor)
    attribute(String, :background, :background)
    attribute(String, :onafterprint, :onafterprint)
    attribute(String, :onbeforeprint, :onbeforeprint)
    attribute(String, :onbeforeunload, :onbeforeunload)
    attribute(String, :onhashchange, :onhashchange)
    attribute(String, :onlanguagechange, :onlanguagechange)
    attribute(String, :onmessage, :onmessage)
    attribute(String, :onoffline, :onoffline)
    attribute(String, :ononline, :ononline)
    attribute(String, :onpagehide, :onpagehide)
    attribute(String, :onpageshow, :onpageshow)
    attribute(String, :onrejectionhandled, :onrejectionhandled)
    attribute(String, :onpopstate, :onpopstate)
    attribute(String, :onstorage, :onstorage)
    attribute(String, :onunhandledrejection, :onunhandledrejection)
    attribute(String, :onunload, :onunload)
  end
  class BodyCollection < ElementCollection
  end

  class Style < HTMLElement
    attribute(String, :media, :media)
    attribute(String, :nonce, :nonce)
    attribute(String, :type, :type)
  end
  class StyleCollection < ElementCollection
  end

  class Meta < HTMLElement
    attribute(String, :name, :name)
    attribute(String, :http_equiv, :httpEquiv)
    attribute(String, :content, :content)
    attribute(String, :scheme, :scheme)
  end
  class MetaCollection < ElementCollection
  end

  class Base < HTMLElement
    attribute(String, :href, :href)
    attribute(String, :target, :target)
  end
  class BaseCollection < ElementCollection
  end

  class Title < HTMLElement
  end
  class TitleCollection < ElementCollection
  end

  class Head < HTMLElement
  end
  class HeadCollection < ElementCollection
  end

  class Html < HTMLElement
    attribute(String, :version, :version)
  end
  class HtmlCollection < ElementCollection
  end

  class Unknown < HTMLElement
  end
  class UnknownCollection < ElementCollection
  end


  module Container

    # @return [Anchor]
    def a(*args)
      Anchor.new(self, extract_selector(args).merge(tag_name: "a"))
    end
    # @return [AnchorCollection]
    def as(*args)
      AnchorCollection.new(self, extract_selector(args).merge(tag_name: "a"))
    end
    Watir.tag_to_class[:a] = Anchor

    # @return [HTMLElement]
    def abbr(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "abbr"))
    end
    # @return [HTMLElementCollection]
    def abbrs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "abbr"))
    end
    Watir.tag_to_class[:abbr] = HTMLElement

    # @return [HTMLElement]
    def address(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "address"))
    end
    # @return [HTMLElementCollection]
    def addresses(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "address"))
    end
    Watir.tag_to_class[:address] = HTMLElement

    # @return [Area]
    def area(*args)
      Area.new(self, extract_selector(args).merge(tag_name: "area"))
    end
    # @return [AreaCollection]
    def areas(*args)
      AreaCollection.new(self, extract_selector(args).merge(tag_name: "area"))
    end
    Watir.tag_to_class[:area] = Area

    # @return [HTMLElement]
    def article(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "article"))
    end
    # @return [HTMLElementCollection]
    def articles(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "article"))
    end
    Watir.tag_to_class[:article] = HTMLElement

    # @return [HTMLElement]
    def aside(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "aside"))
    end
    # @return [HTMLElementCollection]
    def asides(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "aside"))
    end
    Watir.tag_to_class[:aside] = HTMLElement

    # @return [Audio]
    def audio(*args)
      Audio.new(self, extract_selector(args).merge(tag_name: "audio"))
    end
    # @return [AudioCollection]
    def audios(*args)
      AudioCollection.new(self, extract_selector(args).merge(tag_name: "audio"))
    end
    Watir.tag_to_class[:audio] = Audio

    # @return [HTMLElement]
    def b(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "b"))
    end
    # @return [HTMLElementCollection]
    def bs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "b"))
    end
    Watir.tag_to_class[:b] = HTMLElement

    # @return [Base]
    def base(*args)
      Base.new(self, extract_selector(args).merge(tag_name: "base"))
    end
    # @return [BaseCollection]
    def bases(*args)
      BaseCollection.new(self, extract_selector(args).merge(tag_name: "base"))
    end
    Watir.tag_to_class[:base] = Base

    # @return [HTMLElement]
    def bdi(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "bdi"))
    end
    # @return [HTMLElementCollection]
    def bdis(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "bdi"))
    end
    Watir.tag_to_class[:bdi] = HTMLElement

    # @return [HTMLElement]
    def bdo(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "bdo"))
    end
    # @return [HTMLElementCollection]
    def bdos(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "bdo"))
    end
    Watir.tag_to_class[:bdo] = HTMLElement

    # @return [Quote]
    def blockquote(*args)
      Quote.new(self, extract_selector(args).merge(tag_name: "blockquote"))
    end
    # @return [QuoteCollection]
    def blockquotes(*args)
      QuoteCollection.new(self, extract_selector(args).merge(tag_name: "blockquote"))
    end
    Watir.tag_to_class[:blockquote] = Quote

    # @return [Body]
    def body(*args)
      Body.new(self, extract_selector(args).merge(tag_name: "body"))
    end
    # @return [BodyCollection]
    def bodys(*args)
      BodyCollection.new(self, extract_selector(args).merge(tag_name: "body"))
    end
    Watir.tag_to_class[:body] = Body

    # @return [BR]
    def br(*args)
      BR.new(self, extract_selector(args).merge(tag_name: "br"))
    end
    # @return [BRCollection]
    def brs(*args)
      BRCollection.new(self, extract_selector(args).merge(tag_name: "br"))
    end
    Watir.tag_to_class[:br] = BR

    # @return [Button]
    def button(*args)
      Button.new(self, extract_selector(args).merge(tag_name: "button"))
    end
    # @return [ButtonCollection]
    def buttons(*args)
      ButtonCollection.new(self, extract_selector(args).merge(tag_name: "button"))
    end
    Watir.tag_to_class[:button] = Button

    # @return [Canvas]
    def canvas(*args)
      Canvas.new(self, extract_selector(args).merge(tag_name: "canvas"))
    end
    # @return [CanvasCollection]
    def canvases(*args)
      CanvasCollection.new(self, extract_selector(args).merge(tag_name: "canvas"))
    end
    Watir.tag_to_class[:canvas] = Canvas

    # @return [TableCaption]
    def caption(*args)
      TableCaption.new(self, extract_selector(args).merge(tag_name: "caption"))
    end
    # @return [TableCaptionCollection]
    def captions(*args)
      TableCaptionCollection.new(self, extract_selector(args).merge(tag_name: "caption"))
    end
    Watir.tag_to_class[:caption] = TableCaption

    # @return [HTMLElement]
    def cite(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "cite"))
    end
    # @return [HTMLElementCollection]
    def cites(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "cite"))
    end
    Watir.tag_to_class[:cite] = HTMLElement

    # @return [HTMLElement]
    def code(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "code"))
    end
    # @return [HTMLElementCollection]
    def codes(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "code"))
    end
    Watir.tag_to_class[:code] = HTMLElement

    # @return [TableCol]
    def col(*args)
      TableCol.new(self, extract_selector(args).merge(tag_name: "col"))
    end
    # @return [TableColCollection]
    def cols(*args)
      TableColCollection.new(self, extract_selector(args).merge(tag_name: "col"))
    end
    Watir.tag_to_class[:col] = TableCol

    # @return [TableCol]
    def colgroup(*args)
      TableCol.new(self, extract_selector(args).merge(tag_name: "colgroup"))
    end
    # @return [TableColCollection]
    def colgroups(*args)
      TableColCollection.new(self, extract_selector(args).merge(tag_name: "colgroup"))
    end
    Watir.tag_to_class[:colgroup] = TableCol

    # @return [Data]
    def data(*args)
      Data.new(self, extract_selector(args).merge(tag_name: "data"))
    end
    # @return [DataCollection]
    def datas(*args)
      DataCollection.new(self, extract_selector(args).merge(tag_name: "data"))
    end
    Watir.tag_to_class[:data] = Data

    # @return [DataList]
    def datalist(*args)
      DataList.new(self, extract_selector(args).merge(tag_name: "datalist"))
    end
    # @return [DataListCollection]
    def datalists(*args)
      DataListCollection.new(self, extract_selector(args).merge(tag_name: "datalist"))
    end
    Watir.tag_to_class[:datalist] = DataList

    # @return [HTMLElement]
    def dd(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "dd"))
    end
    # @return [HTMLElementCollection]
    def dds(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "dd"))
    end
    Watir.tag_to_class[:dd] = HTMLElement

    # @return [Mod]
    def del(*args)
      Mod.new(self, extract_selector(args).merge(tag_name: "del"))
    end
    # @return [ModCollection]
    def dels(*args)
      ModCollection.new(self, extract_selector(args).merge(tag_name: "del"))
    end
    Watir.tag_to_class[:del] = Mod

    # @return [Details]
    def details(*args)
      Details.new(self, extract_selector(args).merge(tag_name: "details"))
    end
    # @return [DetailsCollection]
    def detailses(*args)
      DetailsCollection.new(self, extract_selector(args).merge(tag_name: "details"))
    end
    Watir.tag_to_class[:details] = Details

    # @return [HTMLElement]
    def dfn(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "dfn"))
    end
    # @return [HTMLElementCollection]
    def dfns(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "dfn"))
    end
    Watir.tag_to_class[:dfn] = HTMLElement

    # @return [Dialog]
    def dialog(*args)
      Dialog.new(self, extract_selector(args).merge(tag_name: "dialog"))
    end
    # @return [DialogCollection]
    def dialogs(*args)
      DialogCollection.new(self, extract_selector(args).merge(tag_name: "dialog"))
    end
    Watir.tag_to_class[:dialog] = Dialog

    # @return [Div]
    def div(*args)
      Div.new(self, extract_selector(args).merge(tag_name: "div"))
    end
    # @return [DivCollection]
    def divs(*args)
      DivCollection.new(self, extract_selector(args).merge(tag_name: "div"))
    end
    Watir.tag_to_class[:div] = Div

    # @return [DList]
    def dl(*args)
      DList.new(self, extract_selector(args).merge(tag_name: "dl"))
    end
    # @return [DListCollection]
    def dls(*args)
      DListCollection.new(self, extract_selector(args).merge(tag_name: "dl"))
    end
    Watir.tag_to_class[:dl] = DList

    # @return [HTMLElement]
    def dt(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "dt"))
    end
    # @return [HTMLElementCollection]
    def dts(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "dt"))
    end
    Watir.tag_to_class[:dt] = HTMLElement

    # @return [HTMLElement]
    def em(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "em"))
    end
    # @return [HTMLElementCollection]
    def ems(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "em"))
    end
    Watir.tag_to_class[:em] = HTMLElement

    # @return [Embed]
    def embed(*args)
      Embed.new(self, extract_selector(args).merge(tag_name: "embed"))
    end
    # @return [EmbedCollection]
    def embeds(*args)
      EmbedCollection.new(self, extract_selector(args).merge(tag_name: "embed"))
    end
    Watir.tag_to_class[:embed] = Embed

    # @return [FieldSet]
    def fieldset(*args)
      FieldSet.new(self, extract_selector(args).merge(tag_name: "fieldset"))
    end
    # @return [FieldSetCollection]
    def fieldsets(*args)
      FieldSetCollection.new(self, extract_selector(args).merge(tag_name: "fieldset"))
    end
    Watir.tag_to_class[:fieldset] = FieldSet

    # @return [HTMLElement]
    def figcaption(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "figcaption"))
    end
    # @return [HTMLElementCollection]
    def figcaptions(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "figcaption"))
    end
    Watir.tag_to_class[:figcaption] = HTMLElement

    # @return [HTMLElement]
    def figure(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "figure"))
    end
    # @return [HTMLElementCollection]
    def figures(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "figure"))
    end
    Watir.tag_to_class[:figure] = HTMLElement

    # @return [HTMLElement]
    def footer(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "footer"))
    end
    # @return [HTMLElementCollection]
    def footers(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "footer"))
    end
    Watir.tag_to_class[:footer] = HTMLElement

    # @return [Form]
    def form(*args)
      Form.new(self, extract_selector(args).merge(tag_name: "form"))
    end
    # @return [FormCollection]
    def forms(*args)
      FormCollection.new(self, extract_selector(args).merge(tag_name: "form"))
    end
    Watir.tag_to_class[:form] = Form

    # @return [FrameSet]
    def frameset(*args)
      FrameSet.new(self, extract_selector(args).merge(tag_name: "frameset"))
    end
    # @return [FrameSetCollection]
    def framesets(*args)
      FrameSetCollection.new(self, extract_selector(args).merge(tag_name: "frameset"))
    end
    Watir.tag_to_class[:frameset] = FrameSet

    # @return [Heading]
    def h1(*args)
      Heading.new(self, extract_selector(args).merge(tag_name: "h1"))
    end
    # @return [HeadingCollection]
    def h1s(*args)
      HeadingCollection.new(self, extract_selector(args).merge(tag_name: "h1"))
    end
    Watir.tag_to_class[:h1] = Heading

    # @return [Heading]
    def h2(*args)
      Heading.new(self, extract_selector(args).merge(tag_name: "h2"))
    end
    # @return [HeadingCollection]
    def h2s(*args)
      HeadingCollection.new(self, extract_selector(args).merge(tag_name: "h2"))
    end
    Watir.tag_to_class[:h2] = Heading

    # @return [Heading]
    def h3(*args)
      Heading.new(self, extract_selector(args).merge(tag_name: "h3"))
    end
    # @return [HeadingCollection]
    def h3s(*args)
      HeadingCollection.new(self, extract_selector(args).merge(tag_name: "h3"))
    end
    Watir.tag_to_class[:h3] = Heading

    # @return [Heading]
    def h4(*args)
      Heading.new(self, extract_selector(args).merge(tag_name: "h4"))
    end
    # @return [HeadingCollection]
    def h4s(*args)
      HeadingCollection.new(self, extract_selector(args).merge(tag_name: "h4"))
    end
    Watir.tag_to_class[:h4] = Heading

    # @return [Heading]
    def h5(*args)
      Heading.new(self, extract_selector(args).merge(tag_name: "h5"))
    end
    # @return [HeadingCollection]
    def h5s(*args)
      HeadingCollection.new(self, extract_selector(args).merge(tag_name: "h5"))
    end
    Watir.tag_to_class[:h5] = Heading

    # @return [Heading]
    def h6(*args)
      Heading.new(self, extract_selector(args).merge(tag_name: "h6"))
    end
    # @return [HeadingCollection]
    def h6s(*args)
      HeadingCollection.new(self, extract_selector(args).merge(tag_name: "h6"))
    end
    Watir.tag_to_class[:h6] = Heading

    # @return [Head]
    def head(*args)
      Head.new(self, extract_selector(args).merge(tag_name: "head"))
    end
    # @return [HeadCollection]
    def heads(*args)
      HeadCollection.new(self, extract_selector(args).merge(tag_name: "head"))
    end
    Watir.tag_to_class[:head] = Head

    # @return [HTMLElement]
    def header(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "header"))
    end
    # @return [HTMLElementCollection]
    def headers(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "header"))
    end
    Watir.tag_to_class[:header] = HTMLElement

    # @return [HR]
    def hr(*args)
      HR.new(self, extract_selector(args).merge(tag_name: "hr"))
    end
    # @return [HRCollection]
    def hrs(*args)
      HRCollection.new(self, extract_selector(args).merge(tag_name: "hr"))
    end
    Watir.tag_to_class[:hr] = HR

    # @return [Html]
    def html(*args)
      Html.new(self, extract_selector(args).merge(tag_name: "html"))
    end
    # @return [HtmlCollection]
    def htmls(*args)
      HtmlCollection.new(self, extract_selector(args).merge(tag_name: "html"))
    end
    Watir.tag_to_class[:html] = Html

    # @return [HTMLElement]
    def i(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "i"))
    end
    # @return [HTMLElementCollection]
    def is(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "i"))
    end
    Watir.tag_to_class[:i] = HTMLElement

    # @return [IFrame]
    def iframe(*args)
      IFrame.new(self, extract_selector(args).merge(tag_name: "iframe"))
    end
    # @return [IFrameCollection]
    def iframes(*args)
      IFrameCollection.new(self, extract_selector(args).merge(tag_name: "iframe"))
    end
    Watir.tag_to_class[:iframe] = IFrame

    # @return [Image]
    def img(*args)
      Image.new(self, extract_selector(args).merge(tag_name: "img"))
    end
    # @return [ImageCollection]
    def imgs(*args)
      ImageCollection.new(self, extract_selector(args).merge(tag_name: "img"))
    end
    Watir.tag_to_class[:img] = Image

    # @return [Input]
    def input(*args)
      Input.new(self, extract_selector(args).merge(tag_name: "input"))
    end
    # @return [InputCollection]
    def inputs(*args)
      InputCollection.new(self, extract_selector(args).merge(tag_name: "input"))
    end
    Watir.tag_to_class[:input] = Input

    # @return [Mod]
    def ins(*args)
      Mod.new(self, extract_selector(args).merge(tag_name: "ins"))
    end
    # @return [ModCollection]
    def inses(*args)
      ModCollection.new(self, extract_selector(args).merge(tag_name: "ins"))
    end
    Watir.tag_to_class[:ins] = Mod

    # @return [HTMLElement]
    def kbd(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "kbd"))
    end
    # @return [HTMLElementCollection]
    def kbds(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "kbd"))
    end
    Watir.tag_to_class[:kbd] = HTMLElement

    # @return [Label]
    def label(*args)
      Label.new(self, extract_selector(args).merge(tag_name: "label"))
    end
    # @return [LabelCollection]
    def labels(*args)
      LabelCollection.new(self, extract_selector(args).merge(tag_name: "label"))
    end
    Watir.tag_to_class[:label] = Label

    # @return [Legend]
    def legend(*args)
      Legend.new(self, extract_selector(args).merge(tag_name: "legend"))
    end
    # @return [LegendCollection]
    def legends(*args)
      LegendCollection.new(self, extract_selector(args).merge(tag_name: "legend"))
    end
    Watir.tag_to_class[:legend] = Legend

    # @return [LI]
    def li(*args)
      LI.new(self, extract_selector(args).merge(tag_name: "li"))
    end
    # @return [LICollection]
    def lis(*args)
      LICollection.new(self, extract_selector(args).merge(tag_name: "li"))
    end
    Watir.tag_to_class[:li] = LI

    # @return [HTMLElement]
    def main(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "main"))
    end
    # @return [HTMLElementCollection]
    def mains(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "main"))
    end
    Watir.tag_to_class[:main] = HTMLElement

    # @return [Map]
    def map(*args)
      Map.new(self, extract_selector(args).merge(tag_name: "map"))
    end
    # @return [MapCollection]
    def maps(*args)
      MapCollection.new(self, extract_selector(args).merge(tag_name: "map"))
    end
    Watir.tag_to_class[:map] = Map

    # @return [HTMLElement]
    def mark(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "mark"))
    end
    # @return [HTMLElementCollection]
    def marks(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "mark"))
    end
    Watir.tag_to_class[:mark] = HTMLElement

    # @return [Meta]
    def meta(*args)
      Meta.new(self, extract_selector(args).merge(tag_name: "meta"))
    end
    # @return [MetaCollection]
    def metas(*args)
      MetaCollection.new(self, extract_selector(args).merge(tag_name: "meta"))
    end
    Watir.tag_to_class[:meta] = Meta

    # @return [Meter]
    def meter(*args)
      Meter.new(self, extract_selector(args).merge(tag_name: "meter"))
    end
    # @return [MeterCollection]
    def meters(*args)
      MeterCollection.new(self, extract_selector(args).merge(tag_name: "meter"))
    end
    Watir.tag_to_class[:meter] = Meter

    # @return [HTMLElement]
    def nav(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "nav"))
    end
    # @return [HTMLElementCollection]
    def navs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "nav"))
    end
    Watir.tag_to_class[:nav] = HTMLElement

    # @return [HTMLElement]
    def noscript(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "noscript"))
    end
    # @return [HTMLElementCollection]
    def noscripts(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "noscript"))
    end
    Watir.tag_to_class[:noscript] = HTMLElement

    # @return [Object]
    def object(*args)
      Object.new(self, extract_selector(args).merge(tag_name: "object"))
    end
    # @return [ObjectCollection]
    def objects(*args)
      ObjectCollection.new(self, extract_selector(args).merge(tag_name: "object"))
    end
    Watir.tag_to_class[:object] = Object

    # @return [OList]
    def ol(*args)
      OList.new(self, extract_selector(args).merge(tag_name: "ol"))
    end
    # @return [OListCollection]
    def ols(*args)
      OListCollection.new(self, extract_selector(args).merge(tag_name: "ol"))
    end
    Watir.tag_to_class[:ol] = OList

    # @return [OptGroup]
    def optgroup(*args)
      OptGroup.new(self, extract_selector(args).merge(tag_name: "optgroup"))
    end
    # @return [OptGroupCollection]
    def optgroups(*args)
      OptGroupCollection.new(self, extract_selector(args).merge(tag_name: "optgroup"))
    end
    Watir.tag_to_class[:optgroup] = OptGroup

    # @return [Option]
    def option(*args)
      Option.new(self, extract_selector(args).merge(tag_name: "option"))
    end
    # @return [OptionCollection]
    def options(*args)
      OptionCollection.new(self, extract_selector(args).merge(tag_name: "option"))
    end
    Watir.tag_to_class[:option] = Option

    # @return [Output]
    def output(*args)
      Output.new(self, extract_selector(args).merge(tag_name: "output"))
    end
    # @return [OutputCollection]
    def outputs(*args)
      OutputCollection.new(self, extract_selector(args).merge(tag_name: "output"))
    end
    Watir.tag_to_class[:output] = Output

    # @return [Paragraph]
    def p(*args)
      Paragraph.new(self, extract_selector(args).merge(tag_name: "p"))
    end
    # @return [ParagraphCollection]
    def ps(*args)
      ParagraphCollection.new(self, extract_selector(args).merge(tag_name: "p"))
    end
    Watir.tag_to_class[:p] = Paragraph

    # @return [Param]
    def param(*args)
      Param.new(self, extract_selector(args).merge(tag_name: "param"))
    end
    # @return [ParamCollection]
    def params(*args)
      ParamCollection.new(self, extract_selector(args).merge(tag_name: "param"))
    end
    Watir.tag_to_class[:param] = Param

    # @return [Picture]
    def picture(*args)
      Picture.new(self, extract_selector(args).merge(tag_name: "picture"))
    end
    # @return [PictureCollection]
    def pictures(*args)
      PictureCollection.new(self, extract_selector(args).merge(tag_name: "picture"))
    end
    Watir.tag_to_class[:picture] = Picture

    # @return [Pre]
    def pre(*args)
      Pre.new(self, extract_selector(args).merge(tag_name: "pre"))
    end
    # @return [PreCollection]
    def pres(*args)
      PreCollection.new(self, extract_selector(args).merge(tag_name: "pre"))
    end
    Watir.tag_to_class[:pre] = Pre

    # @return [Progress]
    def progress(*args)
      Progress.new(self, extract_selector(args).merge(tag_name: "progress"))
    end
    # @return [ProgressCollection]
    def progresses(*args)
      ProgressCollection.new(self, extract_selector(args).merge(tag_name: "progress"))
    end
    Watir.tag_to_class[:progress] = Progress

    # @return [Quote]
    def q(*args)
      Quote.new(self, extract_selector(args).merge(tag_name: "q"))
    end
    # @return [QuoteCollection]
    def qs(*args)
      QuoteCollection.new(self, extract_selector(args).merge(tag_name: "q"))
    end
    Watir.tag_to_class[:q] = Quote

    # @return [HTMLElement]
    def rb(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "rb"))
    end
    # @return [HTMLElementCollection]
    def rbs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "rb"))
    end
    Watir.tag_to_class[:rb] = HTMLElement

    # @return [HTMLElement]
    def rp(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "rp"))
    end
    # @return [HTMLElementCollection]
    def rps(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "rp"))
    end
    Watir.tag_to_class[:rp] = HTMLElement

    # @return [HTMLElement]
    def rt(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "rt"))
    end
    # @return [HTMLElementCollection]
    def rts(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "rt"))
    end
    Watir.tag_to_class[:rt] = HTMLElement

    # @return [HTMLElement]
    def rtc(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "rtc"))
    end
    # @return [HTMLElementCollection]
    def rtcs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "rtc"))
    end
    Watir.tag_to_class[:rtc] = HTMLElement

    # @return [HTMLElement]
    def ruby(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "ruby"))
    end
    # @return [HTMLElementCollection]
    def rubies(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "ruby"))
    end
    Watir.tag_to_class[:ruby] = HTMLElement

    # @return [HTMLElement]
    def s(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "s"))
    end
    # @return [HTMLElementCollection]
    def ss(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "s"))
    end
    Watir.tag_to_class[:s] = HTMLElement

    # @return [HTMLElement]
    def samp(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "samp"))
    end
    # @return [HTMLElementCollection]
    def samps(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "samp"))
    end
    Watir.tag_to_class[:samp] = HTMLElement

    # @return [Script]
    def script(*args)
      Script.new(self, extract_selector(args).merge(tag_name: "script"))
    end
    # @return [ScriptCollection]
    def scripts(*args)
      ScriptCollection.new(self, extract_selector(args).merge(tag_name: "script"))
    end
    Watir.tag_to_class[:script] = Script

    # @return [HTMLElement]
    def section(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "section"))
    end
    # @return [HTMLElementCollection]
    def sections(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "section"))
    end
    Watir.tag_to_class[:section] = HTMLElement

    # @return [Select]
    def select(*args)
      Select.new(self, extract_selector(args).merge(tag_name: "select"))
    end
    # @return [SelectCollection]
    def selects(*args)
      SelectCollection.new(self, extract_selector(args).merge(tag_name: "select"))
    end
    Watir.tag_to_class[:select] = Select

    # @return [HTMLElement]
    def small(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "small"))
    end
    # @return [HTMLElementCollection]
    def smalls(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "small"))
    end
    Watir.tag_to_class[:small] = HTMLElement

    # @return [Source]
    def source(*args)
      Source.new(self, extract_selector(args).merge(tag_name: "source"))
    end
    # @return [SourceCollection]
    def sources(*args)
      SourceCollection.new(self, extract_selector(args).merge(tag_name: "source"))
    end
    Watir.tag_to_class[:source] = Source

    # @return [Span]
    def span(*args)
      Span.new(self, extract_selector(args).merge(tag_name: "span"))
    end
    # @return [SpanCollection]
    def spans(*args)
      SpanCollection.new(self, extract_selector(args).merge(tag_name: "span"))
    end
    Watir.tag_to_class[:span] = Span

    # @return [HTMLElement]
    def strong(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "strong"))
    end
    # @return [HTMLElementCollection]
    def strongs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "strong"))
    end
    Watir.tag_to_class[:strong] = HTMLElement

    # @return [Style]
    def style(*args)
      Style.new(self, extract_selector(args).merge(tag_name: "style"))
    end
    # @return [StyleCollection]
    def styles(*args)
      StyleCollection.new(self, extract_selector(args).merge(tag_name: "style"))
    end
    Watir.tag_to_class[:style] = Style

    # @return [HTMLElement]
    def sub(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "sub"))
    end
    # @return [HTMLElementCollection]
    def subs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "sub"))
    end
    Watir.tag_to_class[:sub] = HTMLElement

    # @return [HTMLElement]
    def summary(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "summary"))
    end
    # @return [HTMLElementCollection]
    def summaries(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "summary"))
    end
    Watir.tag_to_class[:summary] = HTMLElement

    # @return [HTMLElement]
    def sup(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "sup"))
    end
    # @return [HTMLElementCollection]
    def sups(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "sup"))
    end
    Watir.tag_to_class[:sup] = HTMLElement

    # @return [Table]
    def table(*args)
      Table.new(self, extract_selector(args).merge(tag_name: "table"))
    end
    # @return [TableCollection]
    def tables(*args)
      TableCollection.new(self, extract_selector(args).merge(tag_name: "table"))
    end
    Watir.tag_to_class[:table] = Table

    # @return [TableSection]
    def tbody(*args)
      TableSection.new(self, extract_selector(args).merge(tag_name: "tbody"))
    end
    # @return [TableSectionCollection]
    def tbodys(*args)
      TableSectionCollection.new(self, extract_selector(args).merge(tag_name: "tbody"))
    end
    Watir.tag_to_class[:tbody] = TableSection

    # @return [TableDataCell]
    def td(*args)
      TableDataCell.new(self, extract_selector(args).merge(tag_name: "td"))
    end
    # @return [TableDataCellCollection]
    def tds(*args)
      TableDataCellCollection.new(self, extract_selector(args).merge(tag_name: "td"))
    end
    Watir.tag_to_class[:td] = TableDataCell

    # @return [Template]
    def template(*args)
      Template.new(self, extract_selector(args).merge(tag_name: "template"))
    end
    # @return [TemplateCollection]
    def templates(*args)
      TemplateCollection.new(self, extract_selector(args).merge(tag_name: "template"))
    end
    Watir.tag_to_class[:template] = Template

    # @return [TextArea]
    def textarea(*args)
      TextArea.new(self, extract_selector(args).merge(tag_name: "textarea"))
    end
    # @return [TextAreaCollection]
    def textareas(*args)
      TextAreaCollection.new(self, extract_selector(args).merge(tag_name: "textarea"))
    end
    Watir.tag_to_class[:textarea] = TextArea

    # @return [TableSection]
    def tfoot(*args)
      TableSection.new(self, extract_selector(args).merge(tag_name: "tfoot"))
    end
    # @return [TableSectionCollection]
    def tfoots(*args)
      TableSectionCollection.new(self, extract_selector(args).merge(tag_name: "tfoot"))
    end
    Watir.tag_to_class[:tfoot] = TableSection

    # @return [TableHeaderCell]
    def th(*args)
      TableHeaderCell.new(self, extract_selector(args).merge(tag_name: "th"))
    end
    # @return [TableHeaderCellCollection]
    def ths(*args)
      TableHeaderCellCollection.new(self, extract_selector(args).merge(tag_name: "th"))
    end
    Watir.tag_to_class[:th] = TableHeaderCell

    # @return [TableSection]
    def thead(*args)
      TableSection.new(self, extract_selector(args).merge(tag_name: "thead"))
    end
    # @return [TableSectionCollection]
    def theads(*args)
      TableSectionCollection.new(self, extract_selector(args).merge(tag_name: "thead"))
    end
    Watir.tag_to_class[:thead] = TableSection

    # @return [Time]
    def time(*args)
      Time.new(self, extract_selector(args).merge(tag_name: "time"))
    end
    # @return [TimeCollection]
    def times(*args)
      TimeCollection.new(self, extract_selector(args).merge(tag_name: "time"))
    end
    Watir.tag_to_class[:time] = Time

    # @return [Title]
    def title(*args)
      Title.new(self, extract_selector(args).merge(tag_name: "title"))
    end
    # @return [TitleCollection]
    def titles(*args)
      TitleCollection.new(self, extract_selector(args).merge(tag_name: "title"))
    end
    Watir.tag_to_class[:title] = Title

    # @return [TableRow]
    def tr(*args)
      TableRow.new(self, extract_selector(args).merge(tag_name: "tr"))
    end
    # @return [TableRowCollection]
    def trs(*args)
      TableRowCollection.new(self, extract_selector(args).merge(tag_name: "tr"))
    end
    Watir.tag_to_class[:tr] = TableRow

    # @return [Track]
    def track(*args)
      Track.new(self, extract_selector(args).merge(tag_name: "track"))
    end
    # @return [TrackCollection]
    def tracks(*args)
      TrackCollection.new(self, extract_selector(args).merge(tag_name: "track"))
    end
    Watir.tag_to_class[:track] = Track

    # @return [HTMLElement]
    def u(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "u"))
    end
    # @return [HTMLElementCollection]
    def us(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "u"))
    end
    Watir.tag_to_class[:u] = HTMLElement

    # @return [UList]
    def ul(*args)
      UList.new(self, extract_selector(args).merge(tag_name: "ul"))
    end
    # @return [UListCollection]
    def uls(*args)
      UListCollection.new(self, extract_selector(args).merge(tag_name: "ul"))
    end
    Watir.tag_to_class[:ul] = UList

    # @return [HTMLElement]
    def var(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "var"))
    end
    # @return [HTMLElementCollection]
    def vars(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "var"))
    end
    Watir.tag_to_class[:var] = HTMLElement

    # @return [Video]
    def video(*args)
      Video.new(self, extract_selector(args).merge(tag_name: "video"))
    end
    # @return [VideoCollection]
    def videos(*args)
      VideoCollection.new(self, extract_selector(args).merge(tag_name: "video"))
    end
    Watir.tag_to_class[:video] = Video

    # @return [HTMLElement]
    def wbr(*args)
      HTMLElement.new(self, extract_selector(args).merge(tag_name: "wbr"))
    end
    # @return [HTMLElementCollection]
    def wbrs(*args)
      HTMLElementCollection.new(self, extract_selector(args).merge(tag_name: "wbr"))
    end
    Watir.tag_to_class[:wbr] = HTMLElement
  end # Container
end # Watir
