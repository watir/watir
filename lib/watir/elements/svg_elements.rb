# Autogenerated from SVG specification. Edits may be lost.
module Watir
  class SVGElement < HTMLElement
    attribute(String, :classname, :className)
    attribute(String, :ownersvgelement, :ownerSVGElement)
    attribute(String, :viewportelement, :viewportElement)
    attribute(String, :correspondingelement, :correspondingElement)
    attribute(String, :correspondinguseelement, :correspondingUseElement)
  end
  class SVGElementCollection < ElementCollection
  end

  class View < SVGElement
    attribute(String, :viewbox, :viewBox)
    attribute(String, :preserveaspectratio, :preserveAspectRatio)
    attribute(Integer, :zoomandpan, :zoomAndPan)
  end
  class ViewCollection < ElementCollection
  end

  class Pattern < SVGElement
    attribute(String, :patternunits, :patternUnits)
    attribute(String, :patterncontentunits, :patternContentUnits)
    attribute(String, :patterntransform, :patternTransform)
    attribute(Integer, :x, :x)
    attribute(Integer, :y, :y)
    attribute(Integer, :width, :width)
    attribute(Integer, :height, :height)
    attribute(String, :viewbox, :viewBox)
    attribute(String, :preserveaspectratio, :preserveAspectRatio)
    attribute(String, :href, :href)
  end
  class PatternCollection < ElementCollection
  end

  class Stop < SVGElement
    attribute(String, :offset, :offset)
  end
  class StopCollection < ElementCollection
  end

  class Gradient < SVGElement
    attribute(String, :gradientunits, :gradientUnits)
    attribute(String, :gradienttransform, :gradientTransform)
    attribute(String, :spreadmethod, :spreadMethod)
    attribute(String, :href, :href)
  end
  class GradientCollection < ElementCollection
  end

  class RadialGradient < Gradient
    attribute(Integer, :cx, :cx)
    attribute(Integer, :cy, :cy)
    attribute(Integer, :r, :r)
    attribute(Integer, :fx, :fx)
    attribute(Integer, :fy, :fy)
    attribute(Integer, :fr, :fr)
  end
  class RadialGradientCollection < ElementCollection
  end

  class LinearGradient < Gradient
    attribute(Integer, :x1, :x1)
    attribute(Integer, :y1, :y1)
    attribute(Integer, :x2, :x2)
    attribute(Integer, :y2, :y2)
  end
  class LinearGradientCollection < ElementCollection
  end

  class Marker < SVGElement
    attribute(Integer, :refx, :refX)
    attribute(Integer, :refy, :refY)
    attribute(String, :markerunits, :markerUnits)
    attribute(Integer, :markerwidth, :markerWidth)
    attribute(Integer, :markerheight, :markerHeight)
    attribute(String, :orienttype, :orientType)
    attribute(String, :orientangle, :orientAngle)
    attribute(String, :orient, :orient)
    attribute(String, :viewbox, :viewBox)
    attribute(String, :preserveaspectratio, :preserveAspectRatio)
  end
  class MarkerCollection < ElementCollection
  end

  class Metadata < SVGElement
  end
  class MetadataCollection < ElementCollection
  end

  class Desc < SVGElement
  end
  class DescCollection < ElementCollection
  end

  class Graphics < SVGElement
    attribute(String, :transform, :transform)
    attribute(String, :requiredextensions, :requiredExtensions)
    attribute(String, :systemlanguage, :systemLanguage)
  end
  class GraphicsCollection < ElementCollection
  end

  class ForeignObject < Graphics
    attribute(Integer, :x, :x)
    attribute(Integer, :y, :y)
    attribute(Integer, :width, :width)
    attribute(Integer, :height, :height)
  end
  class ForeignObjectCollection < ElementCollection
  end

  class TextContent < Graphics
    attribute(Integer, :textlength, :textLength)
    attribute(String, :lengthadjust, :lengthAdjust)
  end
  class TextContentCollection < ElementCollection
  end

  class TextPath < TextContent
    attribute(Integer, :startoffset, :startOffset)
    attribute(String, :method, :method)
    attribute(String, :spacing, :spacing)
    attribute(String, :href, :href)
  end
  class TextPathCollection < ElementCollection
  end

  class TextPositioning < TextContent
    attribute(String, :x, :x)
    attribute(String, :y, :y)
    attribute(String, :dx, :dx)
    attribute(String, :dy, :dy)
    attribute(String, :rotate, :rotate)
  end
  class TextPositioningCollection < ElementCollection
  end

  class TSpan < TextPositioning
  end
  class TSpanCollection < ElementCollection
  end

  class Switch < Graphics
  end
  class SwitchCollection < ElementCollection
  end

  class Use < Graphics
    attribute(Integer, :x, :x)
    attribute(Integer, :y, :y)
    attribute(Integer, :width, :width)
    attribute(Integer, :height, :height)
    attribute(String, :instanceroot, :instanceRoot)
    attribute(String, :animatedinstanceroot, :animatedInstanceRoot)
    attribute(String, :href, :href)
  end
  class UseCollection < ElementCollection
  end

  class Symbol < Graphics
    attribute(String, :viewbox, :viewBox)
    attribute(String, :preserveaspectratio, :preserveAspectRatio)
  end
  class SymbolCollection < ElementCollection
  end

  class Defs < Graphics
  end
  class DefsCollection < ElementCollection
  end

  class G < Graphics
  end
  class GCollection < ElementCollection
  end

  class SVG < Graphics
    attribute(Integer, :x, :x)
    attribute(Integer, :y, :y)
    attribute(Integer, :width, :width)
    attribute(Integer, :height, :height)
    attribute(Float, :currentscale, :currentScale)
    attribute(String, :currenttranslate, :currentTranslate)
    attribute(String, :viewbox, :viewBox)
    attribute(String, :preserveaspectratio, :preserveAspectRatio)
    attribute(Integer, :zoomandpan, :zoomAndPan)
  end
  class SVGCollection < ElementCollection
  end

  class Geometry < Graphics
    attribute(String, :pathlength, :pathLength)
  end
  class GeometryCollection < ElementCollection
  end

  class Polygon < Geometry
    attribute(String, :points, :points)
    attribute(String, :animatedpoints, :animatedPoints)
  end
  class PolygonCollection < ElementCollection
  end

  class Polyline < Geometry
    attribute(String, :points, :points)
    attribute(String, :animatedpoints, :animatedPoints)
  end
  class PolylineCollection < ElementCollection
  end

  class Line < Geometry
    attribute(Integer, :x1, :x1)
    attribute(Integer, :y1, :y1)
    attribute(Integer, :x2, :x2)
    attribute(Integer, :y2, :y2)
  end
  class LineCollection < ElementCollection
  end

  class Ellipse < Geometry
    attribute(Integer, :cx, :cx)
    attribute(Integer, :cy, :cy)
    attribute(Integer, :rx, :rx)
    attribute(Integer, :ry, :ry)
  end
  class EllipseCollection < ElementCollection
  end

  class Circle < Geometry
    attribute(Integer, :cx, :cx)
    attribute(Integer, :cy, :cy)
    attribute(Integer, :r, :r)
  end
  class CircleCollection < ElementCollection
  end

  class Rect < Geometry
    attribute(Integer, :x, :x)
    attribute(Integer, :y, :y)
    attribute(Integer, :width, :width)
    attribute(Integer, :height, :height)
    attribute(Integer, :rx, :rx)
    attribute(Integer, :ry, :ry)
  end
  class RectCollection < ElementCollection
  end

  class Path < Geometry
  end
  class PathCollection < ElementCollection
  end


  module Container

    # @return [Circle]
    def circle(opts = {})
      Circle.new(self, opts.merge(tag_name: "circle"))
    end
    # @return [CircleCollection]
    def circles(opts = {})
      CircleCollection.new(self, opts.merge(tag_name: "circle"))
    end
    Watir.tag_to_class[:circle] = Circle

    # @return [Defs]
    def defs(opts = {})
      Defs.new(self, opts.merge(tag_name: "defs"))
    end
    # @return [DefsCollection]
    def defss(opts = {})
      DefsCollection.new(self, opts.merge(tag_name: "defs"))
    end
    Watir.tag_to_class[:defs] = Defs

    # @return [Desc]
    def desc(opts = {})
      Desc.new(self, opts.merge(tag_name: "desc"))
    end
    # @return [DescCollection]
    def descs(opts = {})
      DescCollection.new(self, opts.merge(tag_name: "desc"))
    end
    Watir.tag_to_class[:desc] = Desc

    # @return [Ellipse]
    def ellipse(opts = {})
      Ellipse.new(self, opts.merge(tag_name: "ellipse"))
    end
    # @return [EllipseCollection]
    def ellipses(opts = {})
      EllipseCollection.new(self, opts.merge(tag_name: "ellipse"))
    end
    Watir.tag_to_class[:ellipse] = Ellipse

    # @return [ForeignObject]
    def foreign_object(opts = {})
      ForeignObject.new(self, opts.merge(tag_name: "foreignObject"))
    end
    # @return [ForeignObjectCollection]
    def foreign_objects(opts = {})
      ForeignObjectCollection.new(self, opts.merge(tag_name: "foreignObject"))
    end
    Watir.tag_to_class[:foreignObject] = ForeignObject

    # @return [G]
    def g(opts = {})
      G.new(self, opts.merge(tag_name: "g"))
    end
    # @return [GCollection]
    def gs(opts = {})
      GCollection.new(self, opts.merge(tag_name: "g"))
    end
    Watir.tag_to_class[:g] = G

    # @return [Line]
    def line(opts = {})
      Line.new(self, opts.merge(tag_name: "line"))
    end
    # @return [LineCollection]
    def lines(opts = {})
      LineCollection.new(self, opts.merge(tag_name: "line"))
    end
    Watir.tag_to_class[:line] = Line

    # @return [LinearGradient]
    def linear_gradient(opts = {})
      LinearGradient.new(self, opts.merge(tag_name: "linearGradient"))
    end
    # @return [LinearGradientCollection]
    def linear_gradients(opts = {})
      LinearGradientCollection.new(self, opts.merge(tag_name: "linearGradient"))
    end
    Watir.tag_to_class[:linearGradient] = LinearGradient

    # @return [Marker]
    def marker(opts = {})
      Marker.new(self, opts.merge(tag_name: "marker"))
    end
    # @return [MarkerCollection]
    def markers(opts = {})
      MarkerCollection.new(self, opts.merge(tag_name: "marker"))
    end
    Watir.tag_to_class[:marker] = Marker

    # @return [Metadata]
    def metadata(opts = {})
      Metadata.new(self, opts.merge(tag_name: "metadata"))
    end
    # @return [MetadataCollection]
    def metadatas(opts = {})
      MetadataCollection.new(self, opts.merge(tag_name: "metadata"))
    end
    Watir.tag_to_class[:metadata] = Metadata

    # @return [Path]
    def path(opts = {})
      Path.new(self, opts.merge(tag_name: "path"))
    end
    # @return [PathCollection]
    def paths(opts = {})
      PathCollection.new(self, opts.merge(tag_name: "path"))
    end
    Watir.tag_to_class[:path] = Path

    # @return [Pattern]
    def pattern(opts = {})
      Pattern.new(self, opts.merge(tag_name: "pattern"))
    end
    # @return [PatternCollection]
    def patterns(opts = {})
      PatternCollection.new(self, opts.merge(tag_name: "pattern"))
    end
    Watir.tag_to_class[:pattern] = Pattern

    # @return [Polygon]
    def polygon(opts = {})
      Polygon.new(self, opts.merge(tag_name: "polygon"))
    end
    # @return [PolygonCollection]
    def polygons(opts = {})
      PolygonCollection.new(self, opts.merge(tag_name: "polygon"))
    end
    Watir.tag_to_class[:polygon] = Polygon

    # @return [Polyline]
    def polyline(opts = {})
      Polyline.new(self, opts.merge(tag_name: "polyline"))
    end
    # @return [PolylineCollection]
    def polylines(opts = {})
      PolylineCollection.new(self, opts.merge(tag_name: "polyline"))
    end
    Watir.tag_to_class[:polyline] = Polyline

    # @return [RadialGradient]
    def radial_gradient(opts = {})
      RadialGradient.new(self, opts.merge(tag_name: "radialGradient"))
    end
    # @return [RadialGradientCollection]
    def radial_gradients(opts = {})
      RadialGradientCollection.new(self, opts.merge(tag_name: "radialGradient"))
    end
    Watir.tag_to_class[:radialGradient] = RadialGradient

    # @return [Rect]
    def rect(opts = {})
      Rect.new(self, opts.merge(tag_name: "rect"))
    end
    # @return [RectCollection]
    def rects(opts = {})
      RectCollection.new(self, opts.merge(tag_name: "rect"))
    end
    Watir.tag_to_class[:rect] = Rect

    # @return [Stop]
    def stop(opts = {})
      Stop.new(self, opts.merge(tag_name: "stop"))
    end
    # @return [StopCollection]
    def stops(opts = {})
      StopCollection.new(self, opts.merge(tag_name: "stop"))
    end
    Watir.tag_to_class[:stop] = Stop

    # @return [SVG]
    def svg(opts = {})
      SVG.new(self, opts.merge(tag_name: "svg"))
    end
    # @return [SVGCollection]
    def svgs(opts = {})
      SVGCollection.new(self, opts.merge(tag_name: "svg"))
    end
    Watir.tag_to_class[:svg] = SVG

    # @return [Switch]
    def switch(opts = {})
      Switch.new(self, opts.merge(tag_name: "switch"))
    end
    # @return [SwitchCollection]
    def switches(opts = {})
      SwitchCollection.new(self, opts.merge(tag_name: "switch"))
    end
    Watir.tag_to_class[:switch] = Switch

    # @return [Symbol]
    def symbol(opts = {})
      Symbol.new(self, opts.merge(tag_name: "symbol"))
    end
    # @return [SymbolCollection]
    def symbols(opts = {})
      SymbolCollection.new(self, opts.merge(tag_name: "symbol"))
    end
    Watir.tag_to_class[:symbol] = Symbol

    # @return [TextPath]
    def text_path(opts = {})
      TextPath.new(self, opts.merge(tag_name: "textPath"))
    end
    # @return [TextPathCollection]
    def text_paths(opts = {})
      TextPathCollection.new(self, opts.merge(tag_name: "textPath"))
    end
    Watir.tag_to_class[:textPath] = TextPath

    # @return [TSpan]
    def tspan(opts = {})
      TSpan.new(self, opts.merge(tag_name: "tspan"))
    end
    # @return [TSpanCollection]
    def tspans(opts = {})
      TSpanCollection.new(self, opts.merge(tag_name: "tspan"))
    end
    Watir.tag_to_class[:tspan] = TSpan

    # @return [Use]
    def use(opts = {})
      Use.new(self, opts.merge(tag_name: "use"))
    end
    # @return [UseCollection]
    def uses(opts = {})
      UseCollection.new(self, opts.merge(tag_name: "use"))
    end
    Watir.tag_to_class[:use] = Use

    # @return [View]
    def view(opts = {})
      View.new(self, opts.merge(tag_name: "view"))
    end
    # @return [ViewCollection]
    def views(opts = {})
      ViewCollection.new(self, opts.merge(tag_name: "view"))
    end
    Watir.tag_to_class[:view] = View
  end # Container
end # Watir
